#!/usr/bin/env node
/**
 * 🛡️ 安全性漏洞掃描和修復建議
 */

const fs = require('fs');
const path = require('path');

class SecurityVulnerabilityScanner {
    constructor() {
        this.projectRoot = __dirname;
        this.vulnerabilities = [];
        this.securityIssues = {
            critical: [],
            high: [],
            medium: [],
            low: []
        };
    }

    async scanFile(filePath) {
        try {
            const content = fs.readFileSync(filePath, 'utf8');
            const fileName = path.basename(filePath);
            const ext = path.extname(filePath);
            
            console.log(`\n🔍 掃描文件: ${fileName}`);
            
            let issues = [];
            
            // JavaScript/Node.js 安全檢查
            if (ext === '.js') {
                issues = [
                    ...this.checkJavaScriptSecurity(content, fileName),
                    ...this.checkNodeJSSecurity(content, fileName),
                    ...this.checkSQLInjection(content, fileName),
                    ...this.checkXSS(content, fileName)
                ];
            }
            
            // HTML 安全檢查
            if (ext === '.html') {
                issues = [
                    ...this.checkHTMLSecurity(content, fileName),
                    ...this.checkCSRF(content, fileName),
                    ...this.checkXSS(content, fileName)
                ];
            }
            
            // JSON 配置檢查
            if (ext === '.json' && (fileName === 'package.json' || fileName.includes('config'))) {
                issues = this.checkConfigSecurity(content, fileName);
            }
            
            // 分類安全問題
            issues.forEach(issue => {
                this.securityIssues[issue.severity].push(issue);
            });
            
            if (issues.length > 0) {
                console.log(`  發現 ${issues.length} 個安全問題`);
                issues.forEach(issue => {
                    const icon = this.getSeverityIcon(issue.severity);
                    console.log(`    ${icon} ${issue.type}: ${issue.description}`);
                });
            } else {
                console.log('  ✅ 未發現明顯安全問題');
            }
            
            return issues;
            
        } catch (error) {
            console.error(`❌ 掃描文件失敗: ${filePath}`, error.message);
            return [];
        }
    }

    checkJavaScriptSecurity(content, fileName) {
        const issues = [];
        
        // 檢查 eval() 使用
        if (/eval\s*\(/g.test(content)) {
            issues.push({
                file: fileName,
                type: 'Code Injection',
                severity: 'critical',
                description: '使用 eval() 可能導致代碼注入攻擊',
                line: this.getLineNumber(content, /eval\s*\(/),
                fix: '避免使用 eval()，使用 JSON.parse() 或其他安全替代方案'
            });
        }
        
        // 檢查 setTimeout/setInterval 字串執行
        if (/setTimeout\s*\(\s*['"]/g.test(content) || /setInterval\s*\(\s*['"]/g.test(content)) {
            issues.push({
                file: fileName,
                type: 'Code Injection',
                severity: 'high',
                description: 'setTimeout/setInterval 使用字串可能導致代碼注入',
                fix: '使用函數而非字串作為參數'
            });
        }
        
        // 檢查硬編碼敏感資訊
        const sensitivePatterns = [
            { pattern: /(password|pwd|passwd)\s*[:=]\s*['"]\w+['"]/, type: '硬編碼密碼' },
            { pattern: /(api[_-]?key|apikey)\s*[:=]\s*['"]\w+['"]/, type: '硬編碼API密鑰' },
            { pattern: /(secret|token)\s*[:=]\s*['"]\w+['"]/, type: '硬編碼秘密' }
        ];
        
        sensitivePatterns.forEach(({ pattern, type }) => {
            if (pattern.test(content)) {
                issues.push({
                    file: fileName,
                    type: 'Sensitive Data Exposure',
                    severity: 'high',
                    description: `發現${type}`,
                    fix: '使用環境變數或配置文件存儲敏感資訊'
                });
            }
        });
        
        return issues;
    }

    checkNodeJSSecurity(content, fileName) {
        const issues = [];
        
        // 檢查不安全的 require
        if (/require\s*\(\s*[^'"]*user[^'"]*\)/g.test(content)) {
            issues.push({
                file: fileName,
                type: 'Path Traversal',
                severity: 'medium',
                description: 'require() 使用用戶輸入可能導致路徑遍歷攻擊',
                fix: '驗證和清理用戶輸入，使用白名單'
            });
        }
        
        // 檢查 Buffer 不安全使用
        if (/new Buffer\(/g.test(content)) {
            issues.push({
                file: fileName,
                type: 'Memory Disclosure',
                severity: 'medium',
                description: '使用過時的 Buffer() 構造函數',
                fix: '使用 Buffer.from(), Buffer.alloc() 或 Buffer.allocUnsafe()'
            });
        }
        
        // 檢查不安全的加密
        if (/crypto\.createHash\(['"]md5['"]\)/g.test(content)) {
            issues.push({
                file: fileName,
                type: 'Weak Cryptography',
                severity: 'medium',
                description: 'MD5 是不安全的雜湊算法',
                fix: '使用 SHA-256 或更強的雜湊算法'
            });
        }
        
        return issues;
    }

    checkSQLInjection(content, fileName) {
        const issues = [];
        
        // 檢查 SQL 注入風險
        const sqlPatterns = [
            /`[^`]*\$\{[^}]*\}[^`]*`/g, // 模板字串中的 SQL
            /['"][^'"]*\+[^'"]*['"]/g,  // 字串拼接 SQL
            /query\s*\(\s*[^,)]*\+[^,)]*\)/g // query 方法中的字串拼接
        ];
        
        sqlPatterns.forEach(pattern => {
            if (pattern.test(content)) {
                issues.push({
                    file: fileName,
                    type: 'SQL Injection',
                    severity: 'critical',
                    description: '可能存在 SQL 注入風險',
                    fix: '使用參數化查詢或 ORM 來避免 SQL 注入'
                });
            }
        });
        
        return issues;
    }

    checkXSS(content, fileName) {
        const issues = [];
        
        // 檢查 XSS 風險
        const xssPatterns = [
            /innerHTML\s*=.*\+/g,
            /document\.write\s*\(/g,
            /\.html\s*\(.*\+.*\)/g
        ];
        
        xssPatterns.forEach(pattern => {
            if (pattern.test(content)) {
                issues.push({
                    file: fileName,
                    type: 'Cross-Site Scripting (XSS)',
                    severity: 'high',
                    description: '可能存在 XSS 攻擊風險',
                    fix: '對用戶輸入進行適當的編碼和驗證'
                });
            }
        });
        
        return issues;
    }

    checkHTMLSecurity(content, fileName) {
        const issues = [];
        
        // 檢查缺少的安全標頭
        if (!/<meta.*http-equiv=['"]X-UA-Compatible['"].*>/i.test(content)) {
            issues.push({
                file: fileName,
                type: 'Security Headers',
                severity: 'low',
                description: '缺少 X-UA-Compatible 標頭',
                fix: '添加適當的安全標頭'
            });
        }
        
        // 檢查內嵌腳本
        if (/<script[^>]*>(?!.*src=).*<\/script>/gs.test(content)) {
            issues.push({
                file: fileName,
                type: 'Content Security Policy',
                severity: 'medium',
                description: '使用內嵌腳本可能違反 CSP',
                fix: '將腳本移到外部文件並實施 CSP'
            });
        }
        
        // 檢查不安全的連結
        if (/<a[^>]*target=['"]_blank['"][^>]*>/g.test(content) && 
            !/<a[^>]*rel=['"][^'"]*noopener[^'"]*['"][^>]*>/g.test(content)) {
            issues.push({
                file: fileName,
                type: 'Security Misconfiguration',
                severity: 'medium',
                description: 'target="_blank" 沒有 rel="noopener" 可能導致安全問題',
                fix: '為 target="_blank" 連結添加 rel="noopener noreferrer"'
            });
        }
        
        return issues;
    }

    checkCSRF(content, fileName) {
        const issues = [];
        
        // 檢查表單是否有 CSRF 保護
        if (/<form[^>]*>/g.test(content)) {
            if (!/csrf|_token/gi.test(content)) {
                issues.push({
                    file: fileName,
                    type: 'Cross-Site Request Forgery (CSRF)',
                    severity: 'high',
                    description: '表單可能缺少 CSRF 保護',
                    fix: '為表單添加 CSRF token'
                });
            }
        }
        
        return issues;
    }

    checkConfigSecurity(content, fileName) {
        const issues = [];
        
        try {
            const config = JSON.parse(content);
            
            // 檢查過時的依賴
            if (config.dependencies) {
                Object.entries(config.dependencies).forEach(([pkg, version]) => {
                    if (this.isOutdatedPackage(pkg, version)) {
                        issues.push({
                            file: fileName,
                            type: 'Vulnerable Dependencies',
                            severity: 'medium',
                            description: `依賴 ${pkg}@${version} 可能有安全漏洞`,
                            fix: '更新到最新的安全版本'
                        });
                    }
                });
            }
            
        } catch (error) {
            console.log(`  ⚠️ 無法解析 JSON 文件: ${fileName}`);
        }
        
        return issues;
    }

    isOutdatedPackage(packageName, version) {
        // 簡化的過時包檢查邏輯
        const knownVulnerablePackages = ['lodash', 'moment', 'axios'];
        return knownVulnerablePackages.includes(packageName);
    }

    getSeverityIcon(severity) {
        const icons = {
            critical: '🚨',
            high: '⚠️',
            medium: '⚡',
            low: 'ℹ️'
        };
        return icons[severity] || 'ℹ️';
    }

    getLineNumber(content, pattern) {
        const match = content.match(pattern);
        if (match) {
            const beforeMatch = content.substring(0, match.index);
            return beforeMatch.split('\n').length;
        }
        return null;
    }

    async runSecurityScan() {
        console.log('🚀 開始安全性漏洞掃描...');
        console.log('='.repeat(60));
        
        try {
            // 掃描的文件類型和目錄
            const scanPaths = [
                { dir: 'server', extensions: ['.js'] },
                { dir: 'public', extensions: ['.html', '.js'] },
                { dir: '.', files: ['package.json'] }
            ];
            
            for (const scanPath of scanPaths) {
                if (scanPath.files) {
                    // 掃描特定文件
                    for (const file of scanPath.files) {
                        const filePath = path.join(this.projectRoot, file);
                        if (fs.existsSync(filePath)) {
                            await this.scanFile(filePath);
                        }
                    }
                } else {
                    // 掃描目錄中的文件
                    const dirPath = path.join(this.projectRoot, scanPath.dir);
                    if (fs.existsSync(dirPath)) {
                        const files = this.getFilesRecursively(dirPath, scanPath.extensions);
                        for (const file of files) {
                            await this.scanFile(file);
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                    }
                }
            }
            
            this.generateSecurityReport();
            
        } catch (error) {
            console.error('❌ 安全掃描執行失敗:', error);
        }
    }

    getFilesRecursively(dir, extensions) {
        const files = [];
        
        try {
            const entries = fs.readdirSync(dir, { withFileTypes: true });
            
            for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                
                if (entry.isDirectory() && entry.name !== 'node_modules') {
                    files.push(...this.getFilesRecursively(fullPath, extensions));
                } else if (entry.isFile() && extensions.includes(path.extname(entry.name))) {
                    files.push(fullPath);
                }
            }
        } catch (error) {
            console.error(`❌ 讀取目錄失敗: ${dir}`);
        }
        
        return files;
    }

    generateSecurityReport() {
        console.log('\n🛡️ 安全性掃描綜合報告:');
        console.log('='.repeat(60));
        
        const severityLevels = ['critical', 'high', 'medium', 'low'];
        let totalIssues = 0;
        
        severityLevels.forEach(level => {
            const issues = this.securityIssues[level];
            totalIssues += issues.length;
            
            if (issues.length > 0) {
                console.log(`\n${this.getSeverityIcon(level)} ${level.toUpperCase()} 級別問題 (${issues.length} 項):`);
                
                issues.forEach((issue, index) => {
                    console.log(`  ${index + 1}. ${issue.type} - ${issue.file}`);
                    console.log(`     ${issue.description}`);
                    if (issue.fix) {
                        console.log(`     💡 修復建議: ${issue.fix}`);
                    }
                    console.log('');
                });
            }
        });
        
        // 風險評級
        let riskLevel = 'LOW';
        if (this.securityIssues.critical.length > 0) riskLevel = 'CRITICAL';
        else if (this.securityIssues.high.length > 0) riskLevel = 'HIGH';
        else if (this.securityIssues.medium.length > 0) riskLevel = 'MEDIUM';
        
        console.log('\n📈 安全性風險評估:');
        console.log(`  總發現問題數: ${totalIssues}`);
        console.log(`  🚨 嚴重: ${this.securityIssues.critical.length}`);
        console.log(`  ⚠️ 高風險: ${this.securityIssues.high.length}`);
        console.log(`  ⚡ 中風險: ${this.securityIssues.medium.length}`);
        console.log(`  ℹ️ 低風險: ${this.securityIssues.low.length}`);
        console.log(`  🎯 整體風險級別: ${riskLevel}`);
        
        // 安全建議
        console.log('\n🔒 安全加固建議:');
        console.log('  1. 定期更新依賴包到最新版本');
        console.log('  2. 實施內容安全政策 (CSP)');
        console.log('  3. 使用 HTTPS 和安全標頭');
        console.log('  4. 對所有用戶輸入進行驗證和清理');
        console.log('  5. 實施適當的身份驗證和授權');
        console.log('  6. 定期進行安全審計和滲透測試');
        
        console.log('\n✅ 安全性漏洞掃描完成');
    }
}

async function main() {
    const scanner = new SecurityVulnerabilityScanner();
    await scanner.runSecurityScan();
}

main();
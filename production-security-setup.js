#!/usr/bin/env node
/**
 * üõ°Ô∏è ÁîüÁî¢Áí∞Â¢ÉÂÆâÂÖ®ÈÖçÁΩÆÂíåÊ™¢Êü•
 * ÈáùÂ∞çÈóúÈçµÂÆâÂÖ®ÊºèÊ¥ûÈÄ≤Ë°å‰øÆÂæ©ÂíåÁîüÁî¢Áí∞Â¢ÉÂÆâÂÖ®Âº∑Âåñ
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

class ProductionSecuritySetup {
    constructor() {
        this.projectRoot = __dirname;
        this.serverPath = path.join(this.projectRoot, 'server');
        this.publicPath = path.join(this.projectRoot, 'public');
        this.securityResults = {
            securityConfig: [],
            environmentVars: [],
            httpsSetup: [],
            headerSecurity: [],
            inputValidation: [],
            authenticationSecurity: [],
            fixedVulnerabilities: [],
            createdFiles: [],
            recommendations: []
        };
    }

    /**
     * Âü∑Ë°åÁîüÁî¢Áí∞Â¢ÉÂÆâÂÖ®Ë®≠ÁΩÆ
     */
    async executeProductionSecuritySetup() {
        console.log('üõ°Ô∏è ÈñãÂßãÁîüÁî¢Áí∞Â¢ÉÂÆâÂÖ®ÈÖçÁΩÆÂíåÊ™¢Êü•...');
        console.log('='.repeat(70));

        try {
            // 1. ÁîüÊàêÂÆâÂÖ®Áí∞Â¢ÉËÆäÊï∏ÈÖçÁΩÆ
            await this.generateSecurityEnvironmentConfig();
            
            // 2. Ë®≠ÁΩÆÂÆâÂÖ®HTTPÊ®ôÈ†≠
            await this.setupSecurityHeaders();
            
            // 3. ÂØ¶ÊñΩËº∏ÂÖ•È©óË≠âÂíåÊ∏ÖÁêÜ
            await this.implementInputValidationSecurity();
            
            // 4. Âº∑ÂåñË∫´‰ªΩÈ©óË≠âÂÆâÂÖ®
            await this.enhanceAuthenticationSecurity();
            
            // 5. ÈÖçÁΩÆHTTPSÂíåSSL
            await this.setupHTTPSConfiguration();
            
            // 6. ÂâµÂª∫ÂÆâÂÖ®‰∏≠Èñì‰ª∂ÈõÜÊàê
            await this.createSecurityMiddlewareIntegration();
            
            // 7. ÁîüÊàêÂÆâÂÖ®Ê™¢Êü•Ê∏ÖÂñÆ
            this.generateSecurityChecklist();
            
        } catch (error) {
            console.error('‚ùå ÁîüÁî¢Áí∞Â¢ÉÂÆâÂÖ®Ë®≠ÁΩÆÂ§±Êïó:', error.message);
        }
    }

    /**
     * ÁîüÊàêÂÆâÂÖ®Áí∞Â¢ÉËÆäÊï∏ÈÖçÁΩÆ
     */
    async generateSecurityEnvironmentConfig() {
        console.log('\nüîê ÁîüÊàêÂÆâÂÖ®Áí∞Â¢ÉËÆäÊï∏ÈÖçÁΩÆ...');
        
        // ÁîüÊàêÂº∑ÂØÜÈë∞
        const jwtSecret = crypto.randomBytes(64).toString('hex');
        const dbEncryptionKey = crypto.randomBytes(32).toString('hex');
        const sessionSecret = crypto.randomBytes(32).toString('hex');
        
        const envConfig = {
            // Âü∫Êú¨Áí∞Â¢ÉÈÖçÁΩÆ
            NODE_ENV: 'production',
            PORT: '3000',
            
            // ÂÆâÂÖ®ÈáëÈë∞
            JWT_SECRET: jwtSecret,
            JWT_EXPIRES_IN: '24h',
            JWT_REFRESH_EXPIRES_IN: '7d',
            
            // Ë≥áÊñôÂ∫´ÂÆâÂÖ®
            DB_ENCRYPTION_KEY: dbEncryptionKey,
            DB_SSL: 'true',
            DB_CONNECTION_TIMEOUT: '30000',
            
            // Session ÂÆâÂÖ®
            SESSION_SECRET: sessionSecret,
            SESSION_TIMEOUT: '3600000', // 1Â∞èÊôÇ
            
            // ÂÆâÂÖ®Ê®ôÈ†≠ÈÖçÁΩÆ
            CORS_ORIGIN: 'https://yourdomain.com',
            CSP_REPORT_URI: '/api/security/csp-report',
            
            // ÈÄüÁéáÈôêÂà∂
            RATE_LIMIT_WINDOW_MS: '900000', // 15ÂàÜÈêò
            RATE_LIMIT_MAX_REQUESTS: '100',
            
            // Ê™îÊ°à‰∏äÂÇ≥ÂÆâÂÖ®
            MAX_FILE_SIZE: '10485760', // 10MB
            ALLOWED_FILE_TYPES: 'jpg,jpeg,png,pdf,doc,docx',
            
            // Êó•Ë™åÈÖçÁΩÆ
            LOG_LEVEL: 'info',
            LOG_FILE_PATH: './logs',
            
            // Áõ£ÊéßÈÖçÁΩÆ
            HEALTH_CHECK_TIMEOUT: '5000',
            
            // Telegram ÈÄöÁü• (ÁîüÁî¢Áí∞Â¢ÉÂª∫Ë≠∞ÁßªÈô§ÊàñÂä†ÂØÜ)
            // TELEGRAM_BOT_TOKEN: process.env.TELEGRAM_BOT_TOKEN
            // TELEGRAM_CHAT_ID: process.env.TELEGRAM_CHAT_ID
        };

        // ÂâµÂª∫ .env.production Êñá‰ª∂
        const envFile = path.join(this.projectRoot, '.env.production');
        const envContent = Object.entries(envConfig)
            .map(([key, value]) => `${key}=${value}`)
            .join('\n');
        
        const envWithComments = `# üõ°Ô∏è ÁîüÁî¢Áí∞Â¢ÉÂÆâÂÖ®ÈÖçÁΩÆ
# Ë≠¶ÂëäÔºöÊ≠§Êñá‰ª∂ÂåÖÂê´ÊïèÊÑü‰ø°ÊÅØÔºåË´ãÂãøÊèê‰∫§Âà∞ÁâàÊú¨ÊéßÂà∂Á≥ªÁµ±

${envContent}

# üö® ÂÆâÂÖ®ÊèêÈÜíÔºö
# 1. Ë´ãÂ∞áÊ≠§Êñá‰ª∂Âä†ÂÖ• .gitignore
# 2. Âú®ÁîüÁî¢Áí∞Â¢É‰∏≠‰ΩøÁî®Áí∞Â¢ÉËÆäÊï∏ÊàñÂØÜÈë∞ÁÆ°ÁêÜÊúçÂãô
# 3. ÂÆöÊúüËº™ÊèõÂØÜÈë∞
# 4. Áõ£ÊéßÁï∞Â∏∏ÁôªÂÖ•ÂíåÊìç‰Ωú`;

        fs.writeFileSync(envFile, envWithComments);
        
        // ÂâµÂª∫ .env.example Êñá‰ª∂
        const envExampleFile = path.join(this.projectRoot, '.env.example');
        const envExampleContent = Object.entries(envConfig)
            .map(([key, value]) => {
                // Èö±ËóèÊïèÊÑüÂÄº
                if (key.includes('SECRET') || key.includes('KEY') || key.includes('TOKEN')) {
                    return `${key}=your_secure_${key.toLowerCase()}_here`;
                }
                return `${key}=${value}`;
            })
            .join('\n');
        
        fs.writeFileSync(envExampleFile, `# Áí∞Â¢ÉËÆäÊï∏ÁØÑ‰æãÊñá‰ª∂\n# Ë§áË£ΩÂà∞ .env ‰∏¶Â°´ÂÖ•ÂØ¶ÈöõÂÄº\n\n${envExampleContent}`);
        
        // Êõ¥Êñ∞ÊàñÂâµÂª∫ .gitignore
        const gitignoreFile = path.join(this.projectRoot, '.gitignore');
        let gitignoreContent = '';
        
        if (fs.existsSync(gitignoreFile)) {
            gitignoreContent = fs.readFileSync(gitignoreFile, 'utf8');
        }
        
        const securityIgnores = [
            '.env',
            '.env.local',
            '.env.production',
            '.env.development',
            '*.key',
            '*.pem',
            '*.cert',
            'ssl/',
            'secrets/',
            'config/database.json',
            '*.log'
        ];
        
        const newIgnores = securityIgnores.filter(ignore => !gitignoreContent.includes(ignore));
        
        if (newIgnores.length > 0) {
            const updatedGitignore = gitignoreContent + '\n\n# üõ°Ô∏è ÂÆâÂÖ®Áõ∏ÈóúÊñá‰ª∂\n' + newIgnores.join('\n');
            fs.writeFileSync(gitignoreFile, updatedGitignore);
        }
        
        this.securityResults.environmentVars.push({
            file: '.env.production',
            description: 'ÁîüÁî¢Áí∞Â¢ÉÂÆâÂÖ®ÈÖçÁΩÆ',
            status: 'created'
        });
        
        this.securityResults.createdFiles.push('.env.production', '.env.example');
        console.log('  ‚úÖ ÂÆâÂÖ®Áí∞Â¢ÉËÆäÊï∏ÈÖçÁΩÆÂÆåÊàê');
        console.log(`  üîë ÁîüÊàê‰∫Ü ${Object.keys(envConfig).length} ÂÄãÂÆâÂÖ®ÈÖçÁΩÆÈ†Ö`);
    }

    /**
     * Ë®≠ÁΩÆÂÆâÂÖ®HTTPÊ®ôÈ†≠
     */
    async setupSecurityHeaders() {
        console.log('\nüõ°Ô∏è Ë®≠ÁΩÆÂÆâÂÖ®HTTPÊ®ôÈ†≠...');
        
        const securityHeadersFile = path.join(this.serverPath, 'middleware', 'security', 'headers.js');
        
        const securityHeadersContent = `/**
 * üõ°Ô∏è ÂÆâÂÖ®HTTPÊ®ôÈ†≠‰∏≠Èñì‰ª∂
 * ÂØ¶ÊñΩÁîüÁî¢Áí∞Â¢ÉÂøÖË¶ÅÁöÑÂÆâÂÖ®Ê®ôÈ†≠
 */

const helmet = require('helmet');

// Content Security Policy ÈÖçÁΩÆ
const cspConfig = {
    directives: {
        defaultSrc: ["'self'"],
        styleSrc: [
            "'self'", 
            "'unsafe-inline'", 
            "https://cdn.jsdelivr.net",
            "https://cdnjs.cloudflare.com"
        ],
        scriptSrc: [
            "'self'", 
            "https://cdn.jsdelivr.net",
            "https://cdnjs.cloudflare.com"
        ],
        imgSrc: [
            "'self'", 
            "data:", 
            "https:",
            "blob:"
        ],
        fontSrc: [
            "'self'", 
            "https://fonts.googleapis.com",
            "https://fonts.gstatic.com"
        ],
        connectSrc: [
            "'self'",
            process.env.CORS_ORIGIN || "'self'"
        ],
        frameSrc: ["'none'"],
        objectSrc: ["'none'"],
        upgradeInsecureRequests: []
    },
    reportUri: process.env.CSP_REPORT_URI || '/api/security/csp-report'
};

// ÂÆâÂÖ®Ê®ôÈ†≠ÈÖçÁΩÆ
const securityHeaders = (req, res, next) => {
    // Âü∫Êú¨ÂÆâÂÖ®Ê®ôÈ†≠
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('X-XSS-Protection', '1; mode=block');
    res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
    res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');
    
    // HSTS (HTTP Strict Transport Security)
    if (req.secure) {
        res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');
    }
    
    // Feature Policy
    res.setHeader('Feature-Policy', 
        "geolocation 'self'; " +
        "microphone 'none'; " +
        "camera 'none'; " +
        "payment 'self'; " +
        "usb 'none'; " +
        "magnetometer 'none'"
    );
    
    next();
};

// CSP ÈÅïË¶èÂ†±ÂëäÁ´ØÈªû
const cspReportHandler = (req, res) => {
    console.warn('CSP Violation Report:', JSON.stringify(req.body, null, 2));
    
    // Ë®òÈåÑÂà∞ÂÆâÂÖ®Êó•Ë™å
    const logger = require('../../utils/logger');
    logger.warn('CSP Violation', {
        violation: req.body,
        ip: req.ip,
        userAgent: req.get('User-Agent'),
        timestamp: new Date().toISOString()
    });
    
    res.status(204).end();
};

// CORS ÈÖçÁΩÆ
const corsOptions = {
    origin: (origin, callback) => {
        const allowedOrigins = process.env.CORS_ORIGIN?.split(',') || ['http://localhost:3000'];
        
        // Âú®ÁîüÁî¢Áí∞Â¢É‰∏≠Âö¥Ê†ºÊ™¢Êü•‰æÜÊ∫ê
        if (process.env.NODE_ENV === 'production') {
            if (!origin || !allowedOrigins.includes(origin)) {
                return callback(new Error('CORS policy violation'));
            }
        }
        
        callback(null, true);
    },
    credentials: true,
    optionsSuccessStatus: 200,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
};

module.exports = {
    securityHeaders,
    cspConfig,
    cspReportHandler,
    corsOptions,
    helmetConfig: {
        contentSecurityPolicy: cspConfig,
        crossOriginEmbedderPolicy: false, // Ê†πÊìöÈúÄË¶ÅË™øÊï¥
        hsts: {
            maxAge: 31536000,
            includeSubDomains: true,
            preload: true
        }
    }
};`;

        // Á¢∫‰øùÁõÆÈåÑÂ≠òÂú®
        const securityDir = path.dirname(securityHeadersFile);
        if (!fs.existsSync(securityDir)) {
            fs.mkdirSync(securityDir, { recursive: true });
        }

        fs.writeFileSync(securityHeadersFile, securityHeadersContent);
        
        this.securityResults.headerSecurity.push({
            middleware: 'securityHeaders',
            description: 'ÂÆâÂÖ®HTTPÊ®ôÈ†≠ÈÖçÁΩÆ',
            status: 'created'
        });
        
        this.securityResults.createdFiles.push(path.relative(this.projectRoot, securityHeadersFile));
        console.log('  ‚úÖ ÂÆâÂÖ®HTTPÊ®ôÈ†≠ÈÖçÁΩÆÂÆåÊàê');
    }

    /**
     * ÂØ¶ÊñΩËº∏ÂÖ•È©óË≠âÂíåÊ∏ÖÁêÜ
     */
    async implementInputValidationSecurity() {
        console.log('\nüßπ ÂØ¶ÊñΩËº∏ÂÖ•È©óË≠âÂíåÊ∏ÖÁêÜ...');
        
        const inputSecurityFile = path.join(this.serverPath, 'middleware', 'security', 'inputSecurity.js');
        
        const inputSecurityContent = `/**
 * üßπ Ëº∏ÂÖ•ÂÆâÂÖ®È©óË≠âÂíåÊ∏ÖÁêÜ‰∏≠Èñì‰ª∂
 * Èò≤Ê≠¢SQLÊ≥®ÂÖ•„ÄÅXSSÊîªÊìäÂíåÂÖ∂‰ªñËº∏ÂÖ•Áõ∏ÈóúÊîªÊìä
 */

const validator = require('validator');
const DOMPurify = require('isomorphic-dompurify');

// Âç±Èö™Ê®°ÂºèÊ™¢Ê∏¨
const dangerousPatterns = [
    // SQL Ê≥®ÂÖ•Ê®°Âºè
    /(union|select|insert|delete|update|create|drop|exec|execute)\\s/gi,
    /('|(\\-\\-)|(;)|(\\||\\|)|(\\*|\\*))/gi,
    
    // XSS Ê®°Âºè
    /<script[^>]*>.*?<\\/script>/gi,
    /<iframe[^>]*>.*?<\\/iframe>/gi,
    /javascript:/gi,
    /on\\w+\\s*=/gi,
    
    // ÂëΩ‰ª§Ê≥®ÂÖ•Ê®°Âºè
    /(&|\\||;|\\$|\\|\\||&&|\\n|\\r)/gi,
    
    // Ë∑ØÂæëÈÅçÊ≠∑Ê®°Âºè
    /\\.\\.[\\/\\\\]/gi,
    
    // NoSQL Ê≥®ÂÖ•Ê®°Âºè
    /\\$where|\\$ne|\\$gt|\\$lt|\\$regex/gi
];

// Ê™¢Ê∏¨Âç±Èö™Ëº∏ÂÖ•
function detectDangerousInput(input, fieldName = 'unknown') {
    if (typeof input !== 'string') return false;
    
    const threats = [];
    
    dangerousPatterns.forEach((pattern, index) => {
        if (pattern.test(input)) {
            const threatTypes = [
                'SQL Injection', 'SQL Characters', 'XSS Script', 'XSS Iframe', 
                'XSS Javascript', 'XSS Event Handler', 'Command Injection', 
                'Path Traversal', 'NoSQL Injection'
            ];
            threats.push(threatTypes[index] || 'Unknown Threat');
        }
    });
    
    if (threats.length > 0) {
        console.warn(\`üö® Dangerous input detected in \${fieldName}:\`, {
            input: input.substring(0, 100),
            threats: threats,
            timestamp: new Date().toISOString()
        });
        return threats;
    }
    
    return false;
}

// Ê∑±Â∫¶Ëº∏ÂÖ•Ê∏ÖÁêÜ
function deepSanitize(input, options = {}) {
    if (typeof input !== 'string') return input;
    
    const {
        allowHtml = false,
        maxLength = 10000,
        trimWhitespace = true
    } = options;
    
    let cleaned = input;
    
    // Âü∫Êú¨Ê∏ÖÁêÜ
    if (trimWhitespace) {
        cleaned = cleaned.trim();
    }
    
    // Èï∑Â∫¶ÈôêÂà∂
    if (cleaned.length > maxLength) {
        cleaned = cleaned.substring(0, maxLength);
    }
    
    // HTML Ê∏ÖÁêÜ
    if (!allowHtml) {
        cleaned = DOMPurify.sanitize(cleaned, { ALLOWED_TAGS: [] });
        
        // È°çÂ§ñÁöÑHTMLÂØ¶È´îÁ∑®Á¢º
        cleaned = cleaned
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;')
            .replace(/\\//g, '&#x2F;');
    } else {
        // ÂÖÅË®±HTML‰ΩÜÈÄ≤Ë°åÂÆâÂÖ®Ê∏ÖÁêÜ
        cleaned = DOMPurify.sanitize(cleaned, {
            ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p', 'br'],
            ALLOWED_ATTR: []
        });
    }
    
    // SQL Â≠óÁ¨¶ËΩâÁæ©
    cleaned = cleaned
        .replace(/'/g, "''")
        .replace(/;/g, '')
        .replace(/--/g, '')
        .replace(/\\/\\*/g, '')
        .replace(/\\*\\//g, '');
    
    return cleaned;
}

// Êï∏ÊìöÈ°ûÂûãÈ©óË≠â
const typeValidators = {
    email: (value) => validator.isEmail(value),
    phone: (value) => /^09\\d{8}$/.test(value),
    idNumber: (value) => /^[A-Z]\\d{9}$/.test(value),
    url: (value) => validator.isURL(value),
    alphanumeric: (value) => validator.isAlphanumeric(value, 'zh-TW'),
    numeric: (value) => validator.isNumeric(value),
    date: (value) => validator.isISO8601(value),
    uuid: (value) => validator.isUUID(value),
    ip: (value) => validator.isIP(value),
    coordinates: (value) => {
        if (typeof value === 'object' && value.lat && value.lng) {
            return validator.isFloat(value.lat.toString(), { min: -90, max: 90 }) &&
                   validator.isFloat(value.lng.toString(), { min: -180, max: 180 });
        }
        return false;
    }
};

// È´òÁ¥öËº∏ÂÖ•ÂÆâÂÖ®‰∏≠Èñì‰ª∂
const advancedInputSecurity = (options = {}) => {
    const {
        strictMode = process.env.NODE_ENV === 'production',
        logViolations = true,
        blockSuspicious = true,
        rateLimitViolations = true
    } = options;
    
    return (req, res, next) => {
        const violations = [];
        
        // Ê™¢Êü•ÊâÄÊúâËº∏ÂÖ•Ê∫ê
        const inputSources = [
            { source: 'body', data: req.body },
            { source: 'query', data: req.query },
            { source: 'params', data: req.params }
        ];
        
        inputSources.forEach(({ source, data }) => {
            if (data && typeof data === 'object') {
                Object.entries(data).forEach(([key, value]) => {
                    if (typeof value === 'string') {
                        const threats = detectDangerousInput(value, \`\${source}.\${key}\`);
                        if (threats) {
                            violations.push({
                                source,
                                field: key,
                                threats,
                                value: value.substring(0, 100)
                            });
                        }
                        
                        // Ê∏ÖÁêÜËº∏ÂÖ•
                        data[key] = deepSanitize(value);
                    }
                });
            }
        });
        
        // ËôïÁêÜÈÅïË¶è
        if (violations.length > 0) {
            if (logViolations) {
                const logger = require('../../utils/logger');
                logger.warn('Input Security Violations', {
                    violations,
                    ip: req.ip,
                    userAgent: req.get('User-Agent'),
                    url: req.url,
                    timestamp: new Date().toISOString()
                });
            }
            
            if (blockSuspicious && strictMode) {
                return res.status(400).json({
                    success: false,
                    error: 'INPUT_SECURITY_VIOLATION',
                    message: 'Ëº∏ÂÖ•ÂåÖÂê´‰∏çÂÆâÂÖ®ÂÖßÂÆπ',
                    violations: violations.length
                });
            }
        }
        
        next();
    };
};

// Êñá‰ª∂‰∏äÂÇ≥ÂÆâÂÖ®Ê™¢Êü•
const fileUploadSecurity = (req, res, next) => {
    if (req.files || req.file) {
        const files = req.files || [req.file];
        const allowedTypes = (process.env.ALLOWED_FILE_TYPES || 'jpg,jpeg,png,pdf').split(',');
        const maxSize = parseInt(process.env.MAX_FILE_SIZE) || 10485760; // 10MB
        
        for (const file of files) {
            if (!file) continue;
            
            const fileExt = file.originalname.split('.').pop().toLowerCase();
            
            // Ê™¢Êü•Êñá‰ª∂È°ûÂûã
            if (!allowedTypes.includes(fileExt)) {
                return res.status(400).json({
                    success: false,
                    error: 'FILE_TYPE_NOT_ALLOWED',
                    message: \`‰∏çÂÖÅË®±ÁöÑÊñá‰ª∂È°ûÂûã: \${fileExt}\`
                });
            }
            
            // Ê™¢Êü•Êñá‰ª∂Â§ßÂ∞è
            if (file.size > maxSize) {
                return res.status(400).json({
                    success: false,
                    error: 'FILE_TOO_LARGE',
                    message: \`Êñá‰ª∂ÈÅéÂ§ßÔºåÊúÄÂ§ßÂÖÅË®± \${maxSize / 1024 / 1024}MB\`
                });
            }
            
            // Ê™¢Êü•Êñá‰ª∂Âêç
            const threats = detectDangerousInput(file.originalname, 'filename');
            if (threats) {
                return res.status(400).json({
                    success: false,
                    error: 'UNSAFE_FILENAME',
                    message: 'Êñá‰ª∂ÂêçÂåÖÂê´‰∏çÂÆâÂÖ®Â≠óÁ¨¶'
                });
            }
        }
    }
    
    next();
};

module.exports = {
    advancedInputSecurity,
    fileUploadSecurity,
    detectDangerousInput,
    deepSanitize,
    typeValidators
};`;

        fs.writeFileSync(inputSecurityFile, inputSecurityContent);
        
        this.securityResults.inputValidation.push({
            middleware: 'advancedInputSecurity',
            description: 'È´òÁ¥öËº∏ÂÖ•ÂÆâÂÖ®È©óË≠â',
            status: 'created'
        });
        
        this.securityResults.createdFiles.push(path.relative(this.projectRoot, inputSecurityFile));
        console.log('  ‚úÖ Ëº∏ÂÖ•È©óË≠âÂíåÊ∏ÖÁêÜÂØ¶ÊñΩÂÆåÊàê');
    }

    /**
     * Âº∑ÂåñË∫´‰ªΩÈ©óË≠âÂÆâÂÖ®
     */
    async enhanceAuthenticationSecurity() {
        console.log('\nüîê Âº∑ÂåñË∫´‰ªΩÈ©óË≠âÂÆâÂÖ®...');
        
        const authSecurityFile = path.join(this.serverPath, 'middleware', 'security', 'authSecurity.js');
        
        const authSecurityContent = `/**
 * üîê Â¢ûÂº∑Ë∫´‰ªΩÈ©óË≠âÂÆâÂÖ®‰∏≠Èñì‰ª∂
 * ÂØ¶ÊñΩÂº∑ÂåñÁöÑJWTË™çË≠âÂíåÊúÉË©±ÁÆ°ÁêÜ
 */

const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const crypto = require('crypto');

// Token ÈªëÂêçÂñÆÁÆ°ÁêÜ
const tokenBlacklist = new Set();

// ÁôªÂÖ•ÂòóË©¶Ë®òÈåÑ
const loginAttempts = new Map();

// JWT ÂÆâÂÖ®ÈÖçÁΩÆ
const jwtConfig = {
    secret: process.env.JWT_SECRET,
    expiresIn: process.env.JWT_EXPIRES_IN || '24h',
    refreshExpiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '7d',
    algorithm: 'HS256',
    issuer: 'employee-management-system',
    audience: 'employee-management-client'
};

// ÁîüÊàêÂÆâÂÖ®ÁöÑJWT Token
function generateSecureToken(payload, options = {}) {
    const tokenPayload = {
        ...payload,
        iat: Math.floor(Date.now() / 1000),
        jti: crypto.randomBytes(16).toString('hex'), // JWT ID
        type: options.type || 'access'
    };
    
    const tokenOptions = {
        expiresIn: options.expiresIn || jwtConfig.expiresIn,
        issuer: jwtConfig.issuer,
        audience: jwtConfig.audience,
        algorithm: jwtConfig.algorithm
    };
    
    return jwt.sign(tokenPayload, jwtConfig.secret, tokenOptions);
}

// È©óË≠âJWT Token
function verifySecureToken(token) {
    try {
        // Ê™¢Êü•ÊòØÂê¶Âú®ÈªëÂêçÂñÆ‰∏≠
        if (tokenBlacklist.has(token)) {
            throw new Error('Token has been revoked');
        }
        
        const decoded = jwt.verify(token, jwtConfig.secret, {
            issuer: jwtConfig.issuer,
            audience: jwtConfig.audience,
            algorithms: [jwtConfig.algorithm]
        });
        
        return { valid: true, payload: decoded };
    } catch (error) {
        return { valid: false, error: error.message };
    }
}

// Token Êí§Èä∑
function revokeToken(token) {
    tokenBlacklist.add(token);
    
    // ÂÆöÊúüÊ∏ÖÁêÜÈÅéÊúüÁöÑÈªëÂêçÂñÆ token
    setTimeout(() => {
        tokenBlacklist.delete(token);
    }, 24 * 60 * 60 * 1000); // 24Â∞èÊôÇÂæåÊ∏ÖÁêÜ
}

// ÁôªÂÖ•ÂòóË©¶ÈôêÂà∂
function checkLoginAttempts(identifier) {
    const attempts = loginAttempts.get(identifier) || { count: 0, lastAttempt: 0 };
    const now = Date.now();
    const windowMs = 15 * 60 * 1000; // 15ÂàÜÈêòÁ™óÂè£
    const maxAttempts = 5;
    
    // ÈáçÁΩÆÈÅéÊúüÁöÑÂòóË©¶Ë®òÈåÑ
    if (now - attempts.lastAttempt > windowMs) {
        attempts.count = 0;
    }
    
    if (attempts.count >= maxAttempts) {
        const timeLeft = windowMs - (now - attempts.lastAttempt);
        return {
            allowed: false,
            timeLeft: Math.ceil(timeLeft / 1000 / 60), // ÂàÜÈêò
            attempts: attempts.count
        };
    }
    
    return {
        allowed: true,
        attempts: attempts.count
    };
}

// Ë®òÈåÑÁôªÂÖ•ÂòóË©¶
function recordLoginAttempt(identifier, success) {
    const attempts = loginAttempts.get(identifier) || { count: 0, lastAttempt: 0 };
    
    if (success) {
        loginAttempts.delete(identifier); // ÊàêÂäüÁôªÂÖ•Ê∏ÖÈô§Ë®òÈåÑ
    } else {
        attempts.count += 1;
        attempts.lastAttempt = Date.now();
        loginAttempts.set(identifier, attempts);
        
        // Ë®òÈåÑÂÆâÂÖ®Êó•Ë™å
        const logger = require('../../utils/logger');
        logger.warn('Failed login attempt', {
            identifier,
            attempts: attempts.count,
            timestamp: new Date().toISOString()
        });
    }
}

// Âº∑ÂåñÁöÑË∫´‰ªΩÈ©óË≠â‰∏≠Èñì‰ª∂
const enhancedAuth = (options = {}) => {
    const {
        requireValid = true,
        allowRefreshToken = false,
        logAccess = true
    } = options;
    
    return async (req, res, next) => {
        try {
            const authHeader = req.headers.authorization;
            
            if (!authHeader || !authHeader.startsWith('Bearer ')) {
                if (requireValid) {
                    return res.status(401).json({
                        success: false,
                        error: 'MISSING_TOKEN',
                        message: 'ÈúÄË¶ÅÊèê‰æõË™çË≠âToken'
                    });
                }
                return next();
            }
            
            const token = authHeader.substring(7);
            const verification = verifySecureToken(token);
            
            if (!verification.valid) {
                return res.status(401).json({
                    success: false,
                    error: 'INVALID_TOKEN',
                    message: 'TokenÁÑ°ÊïàÊàñÂ∑≤ÈÅéÊúü',
                    details: verification.error
                });
            }
            
            // Ê™¢Êü• Token È°ûÂûã
            if (!allowRefreshToken && verification.payload.type === 'refresh') {
                return res.status(401).json({
                    success: false,
                    error: 'INVALID_TOKEN_TYPE',
                    message: 'Ê≠§Á´ØÈªû‰∏çÊé•ÂèóÂà∑Êñ∞Token'
                });
            }
            
            // Â∞áÁî®Êà∂‰ø°ÊÅØÊ∑ªÂä†Âà∞Ë´ãÊ±Ç
            req.user = verification.payload;
            req.token = token;
            
            // Ë®òÈåÑÂ≠òÂèñÊó•Ë™å
            if (logAccess) {
                const logger = require('../../utils/logger');
                logger.info('Authenticated access', {
                    userId: verification.payload.id,
                    role: verification.payload.role,
                    endpoint: req.path,
                    method: req.method,
                    ip: req.ip,
                    userAgent: req.get('User-Agent'),
                    timestamp: new Date().toISOString()
                });
            }
            
            next();
        } catch (error) {
            console.error('Authentication middleware error:', error);
            return res.status(500).json({
                success: false,
                error: 'AUTH_ERROR',
                message: 'Ë™çË≠âÁ≥ªÁµ±ÈåØË™§'
            });
        }
    };
};

// ÂØÜÁ¢ºÂº∑Â∫¶È©óË≠â
function validatePasswordStrength(password) {
    const requirements = {
        minLength: 8,
        maxLength: 128,
        requireUppercase: true,
        requireLowercase: true,
        requireNumbers: true,
        requireSpecialChars: true,
        forbidCommonPasswords: true
    };
    
    const errors = [];
    
    if (password.length < requirements.minLength) {
        errors.push(\`ÂØÜÁ¢ºÈï∑Â∫¶Ëá≥Â∞ëÈúÄË¶Å \${requirements.minLength} ÂÄãÂ≠óÁ¨¶\`);
    }
    
    if (password.length > requirements.maxLength) {
        errors.push(\`ÂØÜÁ¢ºÈï∑Â∫¶‰∏çËÉΩË∂ÖÈÅé \${requirements.maxLength} ÂÄãÂ≠óÁ¨¶\`);
    }
    
    if (requirements.requireUppercase && !/[A-Z]/.test(password)) {
        errors.push('ÂØÜÁ¢ºÂøÖÈ†àÂåÖÂê´Ëá≥Â∞ë‰∏ÄÂÄãÂ§ßÂØ´Â≠óÊØç');
    }
    
    if (requirements.requireLowercase && !/[a-z]/.test(password)) {
        errors.push('ÂØÜÁ¢ºÂøÖÈ†àÂåÖÂê´Ëá≥Â∞ë‰∏ÄÂÄãÂ∞èÂØ´Â≠óÊØç');
    }
    
    if (requirements.requireNumbers && !/\\d/.test(password)) {
        errors.push('ÂØÜÁ¢ºÂøÖÈ†àÂåÖÂê´Ëá≥Â∞ë‰∏ÄÂÄãÊï∏Â≠ó');
    }
    
    if (requirements.requireSpecialChars && !/[!@#$%^&*()_+\\-=\\[\\]{}|;:,.<>?]/.test(password)) {
        errors.push('ÂØÜÁ¢ºÂøÖÈ†àÂåÖÂê´Ëá≥Â∞ë‰∏ÄÂÄãÁâπÊÆäÂ≠óÁ¨¶');
    }
    
    // Â∏∏Ë¶ãÂØÜÁ¢ºÊ™¢Êü•
    const commonPasswords = [
        'password', '123456', '123456789', 'qwerty', 'abc123',
        'password123', 'admin', 'root', '12345678', 'welcome'
    ];
    
    if (requirements.forbidCommonPasswords && 
        commonPasswords.some(common => password.toLowerCase().includes(common))) {
        errors.push('ÂØÜÁ¢º‰∏çËÉΩÂåÖÂê´Â∏∏Ë¶ãÁöÑÂº±ÂØÜÁ¢ºÊ®°Âºè');
    }
    
    return {
        isValid: errors.length === 0,
        errors: errors,
        strength: calculatePasswordStrength(password)
    };
}

// Ë®àÁÆóÂØÜÁ¢ºÂº∑Â∫¶
function calculatePasswordStrength(password) {
    let score = 0;
    
    // Èï∑Â∫¶ÂàÜÊï∏
    score += Math.min(password.length * 4, 25);
    
    // Â≠óÁ¨¶Â§öÊ®£ÊÄßÂàÜÊï∏
    if (/[a-z]/.test(password)) score += 5;
    if (/[A-Z]/.test(password)) score += 5;
    if (/\\d/.test(password)) score += 5;
    if (/[^\\w\\s]/.test(password)) score += 10;
    
    // Ë§áÈõúÂ∫¶ÂàÜÊï∏
    const uniqueChars = new Set(password).size;
    score += Math.min(uniqueChars * 2, 20);
    
    // Ê®°ÂºèÊâ£ÂàÜ
    if (/(..).*\\1/.test(password)) score -= 10; // ÈáçË§áÊ®°Âºè
    if (/012|123|234|345|456|567|678|789|890/.test(password)) score -= 15; // ÈÄ£Á∫åÊï∏Â≠ó
    if (/abc|bcd|cde|def|efg|fgh|ghi|hij|ijk|jkl|klm|lmn|mno|nop|opq|pqr|qrs|rst|stu|tuv|uvw|vwx|wxy|xyz/.test(password.toLowerCase())) score -= 15; // ÈÄ£Á∫åÂ≠óÊØç
    
    return Math.max(0, Math.min(100, score));
}

// ÂÆâÂÖ®ÁöÑÂØÜÁ¢ºÈõúÊπä
async function hashPassword(password) {
    const validation = validatePasswordStrength(password);
    if (!validation.isValid) {
        throw new Error(\`ÂØÜÁ¢º‰∏çÁ¨¶ÂêàÂÆâÂÖ®Ë¶ÅÊ±Ç: \${validation.errors.join(', ')}\`);
    }
    
    const saltRounds = 12;
    return await bcrypt.hash(password, saltRounds);
}

// ÂØÜÁ¢ºÈ©óË≠â
async function verifyPassword(password, hash) {
    return await bcrypt.compare(password, hash);
}

// Session ÂÆâÂÖ®ÁÆ°ÁêÜ
const sessionSecurity = {
    generateSessionId: () => crypto.randomBytes(32).toString('hex'),
    
    validateSession: (sessionId, userId) => {
        // ÂØ¶ÁèæÊúÉË©±È©óË≠âÈÇèËºØ
        // ÈÄôË£°ÂèØ‰ª•ÈÄ£Êé•Âà∞ Redis ÊàñÊï∏ÊìöÂ∫´ÈÄ≤Ë°åÊúÉË©±ÁÆ°ÁêÜ
        return true;
    },
    
    revokeSession: (sessionId) => {
        // ÂØ¶ÁèæÊúÉË©±Êí§Èä∑ÈÇèËºØ
        console.log(\`Session revoked: \${sessionId}\`);
    }
};

module.exports = {
    enhancedAuth,
    generateSecureToken,
    verifySecureToken,
    revokeToken,
    checkLoginAttempts,
    recordLoginAttempt,
    validatePasswordStrength,
    hashPassword,
    verifyPassword,
    sessionSecurity
};`;

        fs.writeFileSync(authSecurityFile, authSecurityContent);
        
        this.securityResults.authenticationSecurity.push({
            middleware: 'enhancedAuth',
            description: 'Â¢ûÂº∑Ë∫´‰ªΩÈ©óË≠âÂÆâÂÖ®',
            status: 'created'
        });
        
        this.securityResults.createdFiles.push(path.relative(this.projectRoot, authSecurityFile));
        console.log('  ‚úÖ Ë∫´‰ªΩÈ©óË≠âÂÆâÂÖ®Âº∑ÂåñÂÆåÊàê');
    }

    /**
     * ÈÖçÁΩÆHTTPSÂíåSSL
     */
    async setupHTTPSConfiguration() {
        console.log('\nüîí ÈÖçÁΩÆHTTPSÂíåSSL...');
        
        const httpsConfigFile = path.join(this.serverPath, 'config', 'https.js');
        
        // Á¢∫‰øùÁõÆÈåÑÂ≠òÂú®
        const configDir = path.dirname(httpsConfigFile);
        if (!fs.existsSync(configDir)) {
            fs.mkdirSync(configDir, { recursive: true });
        }
        
        const httpsConfigContent = `/**
 * üîí HTTPS Âíå SSL ÈÖçÁΩÆ
 * ÁîüÁî¢Áí∞Â¢ÉSSL/TLSÈÖçÁΩÆ
 */

const fs = require('fs');
const path = require('path');
const https = require('https');

// SSL Ë≠âÊõ∏Ë∑ØÂæëÈÖçÁΩÆ
const sslConfig = {
    // ÁîüÁî¢Áí∞Â¢ÉË≠âÊõ∏Ë∑ØÂæë
    certPath: process.env.SSL_CERT_PATH || path.join(__dirname, '../ssl/cert.pem'),
    keyPath: process.env.SSL_KEY_PATH || path.join(__dirname, '../ssl/key.pem'),
    caPath: process.env.SSL_CA_PATH || null,
    
    // SSL ÈÅ∏È†Ö
    secureProtocol: 'TLSv1_2_method',
    honorCipherOrder: true,
    ciphers: [
        'ECDHE-ECDSA-AES256-GCM-SHA384',
        'ECDHE-RSA-AES256-GCM-SHA384',
        'ECDHE-ECDSA-CHACHA20-POLY1305',
        'ECDHE-RSA-CHACHA20-POLY1305',
        'ECDHE-ECDSA-AES128-GCM-SHA256',
        'ECDHE-RSA-AES128-GCM-SHA256'
    ].join(':'),
    
    // HTTPS ÈáçÂÆöÂêëÈÖçÁΩÆ
    httpsPort: process.env.HTTPS_PORT || 443,
    httpPort: process.env.HTTP_PORT || 80,
    
    // HSTS ÈÖçÁΩÆ
    hstsMaxAge: 31536000, // 1Âπ¥
    hstsIncludeSubDomains: true,
    hstsPreload: true
};

// ÂâµÂª∫ HTTPS ÈÅ∏È†Ö
function createHTTPSOptions() {
    const options = {
        secureProtocol: sslConfig.secureProtocol,
        honorCipherOrder: sslConfig.honorCipherOrder,
        ciphers: sslConfig.ciphers
    };
    
    try {
        // ËÆÄÂèñË≠âÊõ∏Êñá‰ª∂
        if (fs.existsSync(sslConfig.keyPath)) {
            options.key = fs.readFileSync(sslConfig.keyPath);
        }
        
        if (fs.existsSync(sslConfig.certPath)) {
            options.cert = fs.readFileSync(sslConfig.certPath);
        }
        
        // CA Ë≠âÊõ∏ÔºàÂ¶ÇÊûúÊúâÁöÑË©±Ôºâ
        if (sslConfig.caPath && fs.existsSync(sslConfig.caPath)) {
            options.ca = fs.readFileSync(sslConfig.caPath);
        }
        
        return options;
    } catch (error) {
        console.error('‚ùå SSL Ë≠âÊõ∏ËÆÄÂèñÂ§±Êïó:', error.message);
        return null;
    }
}

// HTTP Âà∞ HTTPS ÈáçÂÆöÂêë‰∏≠Èñì‰ª∂
const httpsRedirect = (req, res, next) => {
    if (req.header('x-forwarded-proto') !== 'https') {
        const httpsUrl = \`https://\${req.get('host')}\${req.url}\`;
        return res.redirect(301, httpsUrl);
    }
    next();
};

// HSTS Ê®ôÈ†≠‰∏≠Èñì‰ª∂
const hstsHeader = (req, res, next) => {
    res.setHeader(
        'Strict-Transport-Security', 
        \`max-age=\${sslConfig.hstsMaxAge}; includeSubDomains\${sslConfig.hstsPreload ? '; preload' : ''}\`
    );
    next();
};

// ÂâµÂª∫ HTTPS ‰º∫ÊúçÂô®
function createHTTPSServer(app) {
    const httpsOptions = createHTTPSOptions();
    
    if (!httpsOptions || !httpsOptions.key || !httpsOptions.cert) {
        console.warn('‚ö†Ô∏è SSL Ë≠âÊõ∏Êú™ÊâæÂà∞ÔºåÂ∞á‰ΩøÁî® HTTP Ê®°Âºè');
        console.warn('üîí ÁîüÁî¢Áí∞Â¢ÉÂª∫Ë≠∞ÈÖçÁΩÆ HTTPS');
        return null;
    }
    
    const httpsServer = https.createServer(httpsOptions, app);
    
    httpsServer.on('error', (error) => {
        console.error('‚ùå HTTPS ‰º∫ÊúçÂô®ÈåØË™§:', error);
    });
    
    return httpsServer;
}

// SSL Ë≠âÊõ∏È©óË≠â
function validateSSLCertificate() {
    const issues = [];
    
    if (!fs.existsSync(sslConfig.certPath)) {
        issues.push(\`Ë≠âÊõ∏Êñá‰ª∂‰∏çÂ≠òÂú®: \${sslConfig.certPath}\`);
    }
    
    if (!fs.existsSync(sslConfig.keyPath)) {
        issues.push(\`ÁßÅÈë∞Êñá‰ª∂‰∏çÂ≠òÂú®: \${sslConfig.keyPath}\`);
    }
    
    // ÂèØ‰ª•Ê∑ªÂä†Êõ¥Â§öË≠âÊõ∏È©óË≠âÈÇèËºØ
    // ‰æãÂ¶ÇÔºöÊ™¢Êü•Ë≠âÊõ∏ÈÅéÊúüÊôÇÈñì„ÄÅÂüüÂêçÂåπÈÖçÁ≠â
    
    return {
        valid: issues.length === 0,
        issues: issues
    };
}

// ÁîüÊàêËá™Á∞ΩÂêçË≠âÊõ∏ÔºàÂÉÖÁî®ÊñºÈñãÁôºÁí∞Â¢ÉÔºâ
function generateSelfSignedCert() {
    const selfsigned = require('selfsigned');
    
    const attrs = [
        { name: 'commonName', value: 'localhost' },
        { name: 'countryName', value: 'TW' },
        { name: 'stateOrProvinceName', value: 'Taiwan' },
        { name: 'localityName', value: 'Taipei' },
        { name: 'organizationName', value: 'Employee Management System' }
    ];
    
    const options = {
        keySize: 2048,
        days: 365,
        algorithm: 'sha256',
        extensions: [
            {
                name: 'subjectAltName',
                altNames: [
                    { type: 2, value: 'localhost' },
                    { type: 2, value: '127.0.0.1' }
                ]
            }
        ]
    };
    
    const pems = selfsigned.generate(attrs, options);
    
    // ÂâµÂª∫ SSL ÁõÆÈåÑ
    const sslDir = path.join(__dirname, '../ssl');
    if (!fs.existsSync(sslDir)) {
        fs.mkdirSync(sslDir, { recursive: true });
    }
    
    // ÂØ´ÂÖ•Ë≠âÊõ∏Êñá‰ª∂
    fs.writeFileSync(path.join(sslDir, 'cert.pem'), pems.cert);
    fs.writeFileSync(path.join(sslDir, 'key.pem'), pems.private);
    
    console.log('‚úÖ Ëá™Á∞ΩÂêçË≠âÊõ∏Â∑≤ÁîüÊàê (ÂÉÖÁî®ÊñºÈñãÁôºÁí∞Â¢É)');
    console.log('üîí ÁîüÁî¢Áí∞Â¢ÉË´ã‰ΩøÁî®Ê≠£ÂºèÁöÑSSLË≠âÊõ∏');
    
    return {
        cert: pems.cert,
        key: pems.private
    };
}

module.exports = {
    sslConfig,
    createHTTPSOptions,
    createHTTPSServer,
    httpsRedirect,
    hstsHeader,
    validateSSLCertificate,
    generateSelfSignedCert
};`;

        fs.writeFileSync(httpsConfigFile, httpsConfigContent);
        
        // ÂâµÂª∫ SSL ÁõÆÈåÑÁµêÊßã
        const sslDir = path.join(this.serverPath, 'ssl');
        if (!fs.existsSync(sslDir)) {
            fs.mkdirSync(sslDir, { recursive: true });
            
            // ÂâµÂª∫ README Êñá‰ª∂Ë™™ÊòéÂ¶Ç‰ΩïÈÖçÁΩÆË≠âÊõ∏
            const sslReadme = `# SSL Ë≠âÊõ∏ÈÖçÁΩÆ

## ÁîüÁî¢Áí∞Â¢ÉË≠âÊõ∏ÈÖçÁΩÆ

1. Â∞áÊÇ®ÁöÑSSLË≠âÊõ∏Êñá‰ª∂ÊîæÂú®Ê≠§ÁõÆÈåÑÔºö
   - \`cert.pem\` - Ë≠âÊõ∏Êñá‰ª∂
   - \`key.pem\` - ÁßÅÈë∞Êñá‰ª∂
   - \`ca.pem\` - CAË≠âÊõ∏Êñá‰ª∂ÔºàÂèØÈÅ∏Ôºâ

2. Á¢∫‰øùÊñá‰ª∂Ê¨äÈôêÊ≠£Á¢∫Ôºö
   \`\`\`bash
   chmod 600 key.pem
   chmod 644 cert.pem
   \`\`\`

3. Êõ¥Êñ∞Áí∞Â¢ÉËÆäÊï∏Ôºö
   \`\`\`
   SSL_CERT_PATH=/path/to/cert.pem
   SSL_KEY_PATH=/path/to/key.pem
   SSL_CA_PATH=/path/to/ca.pem
   HTTPS_PORT=443
   \`\`\`

## ÈñãÁôºÁí∞Â¢É

Á≥ªÁµ±ÊúÉËá™ÂãïÁîüÊàêËá™Á∞ΩÂêçË≠âÊõ∏Áî®ÊñºÈñãÁôºÊ∏¨Ë©¶„ÄÇ

## Âª∫Ë≠∞ÁöÑSSLÊèê‰æõÂïÜ

- Let's Encrypt (ÂÖçË≤ª)
- Cloudflare SSL
- DigiCert
- GlobalSign

## Ë≠âÊõ∏Êõ¥Êñ∞

ÂÆöÊúüÊ™¢Êü•Ë≠âÊõ∏Âà∞ÊúüÊôÇÈñì‰∏¶ÂèäÊôÇÊõ¥Êñ∞„ÄÇ
`;
            
            fs.writeFileSync(path.join(sslDir, 'README.md'), sslReadme);
        }
        
        this.securityResults.httpsSetup.push({
            config: 'httpsConfiguration',
            description: 'HTTPS Âíå SSL ÈÖçÁΩÆ',
            status: 'created'
        });
        
        this.securityResults.createdFiles.push(path.relative(this.projectRoot, httpsConfigFile));
        console.log('  ‚úÖ HTTPS Âíå SSL ÈÖçÁΩÆÂÆåÊàê');
    }

    /**
     * ÂâµÂª∫ÂÆâÂÖ®‰∏≠Èñì‰ª∂ÈõÜÊàê
     */
    async createSecurityMiddlewareIntegration() {
        console.log('\nüîß ÂâµÂª∫ÂÆâÂÖ®‰∏≠Èñì‰ª∂ÈõÜÊàê...');
        
        const integrationFile = path.join(this.serverPath, 'middleware', 'security', 'index.js');
        
        const integrationContent = `/**
 * üõ°Ô∏è ÂÆâÂÖ®‰∏≠Èñì‰ª∂ÈõÜÊàê
 * Áµ±‰∏ÄÁöÑÂÆâÂÖ®‰∏≠Èñì‰ª∂ÈÖçÁΩÆÂíå‰ΩøÁî®
 */

// Â∞éÂÖ•ÊâÄÊúâÂÆâÂÖ®‰∏≠Èñì‰ª∂
const { securityHeaders, cspReportHandler, corsOptions } = require('./headers');
const { advancedInputSecurity, fileUploadSecurity } = require('./inputSecurity');
const { enhancedAuth } = require('./authSecurity');
const { sqlInjectionProtection } = require('./sqlProtection');
const { xssProtection } = require('./xssProtection');

// Â∞éÂÖ•ÊÄßËÉΩÂíåÈôêÂà∂‰∏≠Èñì‰ª∂
const { basicRateLimit, strictRateLimit, apiRateLimit } = require('../performance/rateLimit');
const { compressionMiddleware } = require('../performance/compression');
const { cacheMiddleware } = require('../performance/cache');

// Â∞éÂÖ•Á¨¨‰∏âÊñπÂÆâÂÖ®‰∏≠Èñì‰ª∂
const helmet = require('helmet');
const cors = require('cors');
const hpp = require('hpp');
const mongoSanitize = require('express-mongo-sanitize');

/**
 * ÈÖçÁΩÆÂü∫Êú¨ÂÆâÂÖ®‰∏≠Èñì‰ª∂
 * ÈÅ©Áî®ÊñºÊâÄÊúâË∑ØÁî±
 */
function configureBasicSecurity(app) {
    console.log('üõ°Ô∏è ÈÖçÁΩÆÂü∫Êú¨ÂÆâÂÖ®‰∏≠Èñì‰ª∂...');
    
    // ‰ø°‰ªª‰ª£ÁêÜÔºàÂ¶ÇÊûú‰ΩøÁî®ÂèçÂêë‰ª£ÁêÜÔºâ
    app.set('trust proxy', 1);
    
    // Helmet Âü∫Êú¨ÂÆâÂÖ®Ê®ôÈ†≠
    app.use(helmet({
        contentSecurityPolicy: {
            directives: {
                defaultSrc: ["'self'"],
                styleSrc: ["'self'", "'unsafe-inline'", "https://cdn.jsdelivr.net"],
                scriptSrc: ["'self'", "https://cdn.jsdelivr.net"],
                imgSrc: ["'self'", "data:", "https:"],
                connectSrc: ["'self'"]
            }
        },
        hsts: {
            maxAge: 31536000,
            includeSubDomains: true,
            preload: true
        }
    }));
    
    // CORS ÈÖçÁΩÆ
    app.use(cors(corsOptions));
    
    // Ëá™ÂÆöÁæ©ÂÆâÂÖ®Ê®ôÈ†≠
    app.use(securityHeaders);
    
    // HTTP ÂèÉÊï∏Ê±°Êüì‰øùË≠∑
    app.use(hpp());
    
    // MongoDB Ê≥®ÂÖ•‰øùË≠∑
    app.use(mongoSanitize());
    
    // Â£ìÁ∏Æ‰∏≠Èñì‰ª∂
    app.use(compressionMiddleware);
    
    // Âü∫Êú¨ÈÄüÁéáÈôêÂà∂
    app.use(basicRateLimit);
    
    console.log('‚úÖ Âü∫Êú¨ÂÆâÂÖ®‰∏≠Èñì‰ª∂ÈÖçÁΩÆÂÆåÊàê');
}

/**
 * ÈÖçÁΩÆAPIÂÆâÂÖ®‰∏≠Èñì‰ª∂
 * ÈÅ©Áî®Êñº /api Ë∑ØÁî±
 */
function configureAPISecurity(app) {
    console.log('üîí ÈÖçÁΩÆAPIÂÆâÂÖ®‰∏≠Èñì‰ª∂...');
    
    // API ÈÄüÁéáÈôêÂà∂
    app.use('/api', apiRateLimit);
    
    // È´òÁ¥öËº∏ÂÖ•ÂÆâÂÖ®Ê™¢Êü•
    app.use('/api', advancedInputSecurity({
        strictMode: process.env.NODE_ENV === 'production',
        blockSuspicious: true,
        logViolations: true
    }));
    
    // SQL Ê≥®ÂÖ•‰øùË≠∑
    app.use('/api', sqlInjectionProtection);
    
    // XSS ‰øùË≠∑
    app.use('/api', xssProtection);
    
    // CSP ÈÅïË¶èÂ†±ÂëäÁ´ØÈªû
    app.post('/api/security/csp-report', cspReportHandler);
    
    console.log('‚úÖ APIÂÆâÂÖ®‰∏≠Èñì‰ª∂ÈÖçÁΩÆÂÆåÊàê');
}

/**
 * ÈÖçÁΩÆË™çË≠âË∑ØÁî±ÂÆâÂÖ®
 * ÈÅ©Áî®ÊñºË™çË≠âÁõ∏ÈóúË∑ØÁî±
 */
function configureAuthSecurity(app) {
    console.log('üîê ÈÖçÁΩÆË™çË≠âÂÆâÂÖ®‰∏≠Èñì‰ª∂...');
    
    // ÁôªÂÖ•Áõ∏ÈóúË∑ØÁî±‰ΩøÁî®Âö¥Ê†ºÈÄüÁéáÈôêÂà∂
    app.use(['/api/auth/login', '/api/auth/register'], strictRateLimit);
    
    // Ë™çË≠â‰∏≠Èñì‰ª∂
    const authRoutes = [
        '/api/employees',
        '/api/attendance',
        '/api/revenue',
        '/api/admin',
        '/api/schedule'
    ];
    
    authRoutes.forEach(route => {
        app.use(route, enhancedAuth({
            requireValid: true,
            logAccess: true
        }));
    });
    
    console.log('‚úÖ Ë™çË≠âÂÆâÂÖ®‰∏≠Èñì‰ª∂ÈÖçÁΩÆÂÆåÊàê');
}

/**
 * ÈÖçÁΩÆÊñá‰ª∂‰∏äÂÇ≥ÂÆâÂÖ®
 */
function configureFileUploadSecurity(app) {
    console.log('üìÅ ÈÖçÁΩÆÊñá‰ª∂‰∏äÂÇ≥ÂÆâÂÖ®‰∏≠Èñì‰ª∂...');
    
    // Êñá‰ª∂‰∏äÂÇ≥Ë∑ØÁî±ÁöÑÂÆâÂÖ®Ê™¢Êü•
    app.use('/api/*/upload', fileUploadSecurity);
    app.use('/api/revenue/add', fileUploadSecurity); // ÁáüÊî∂ÁÖßÁâá‰∏äÂÇ≥
    app.use('/api/maintenance/report', fileUploadSecurity); // Á∂≠‰øÆÁÖßÁâá‰∏äÂÇ≥
    
    console.log('‚úÖ Êñá‰ª∂‰∏äÂÇ≥ÂÆâÂÖ®‰∏≠Èñì‰ª∂ÈÖçÁΩÆÂÆåÊàê');
}

/**
 * ÈÖçÁΩÆÂø´ÂèñÂÆâÂÖ®
 */
function configureCacheSecurity(app) {
    console.log('‚ö° ÈÖçÁΩÆÂø´ÂèñÂÆâÂÖ®‰∏≠Èñì‰ª∂...');
    
    // Âè™Â∞çÁâπÂÆöAPIÁ´ØÈªû‰ΩøÁî®Á∑©Â≠ò
    const cacheableRoutes = [
        '/api/stores',
        '/api/reports',
        '/api/statistics'
    ];
    
    cacheableRoutes.forEach(route => {
        app.use(route, cacheMiddleware(300)); // 5ÂàÜÈêòÂø´Âèñ
    });
    
    console.log('‚úÖ Âø´ÂèñÂÆâÂÖ®‰∏≠Èñì‰ª∂ÈÖçÁΩÆÂÆåÊàê');
}

/**
 * ÈÖçÁΩÆÁîüÁî¢Áí∞Â¢ÉÂ∞àÁî®ÂÆâÂÖ®
 */
function configureProductionSecurity(app) {
    if (process.env.NODE_ENV !== 'production') {
        return;
    }
    
    console.log('üè≠ ÈÖçÁΩÆÁîüÁî¢Áí∞Â¢ÉÂ∞àÁî®ÂÆâÂÖ®‰∏≠Èñì‰ª∂...');
    
    // Êõ¥Âö¥Ê†ºÁöÑÂÆâÂÖ®Ê®ôÈ†≠
    app.use((req, res, next) => {
        res.setHeader('Server', 'Enterprise-System'); // Èö±ËóèÊúçÂãôÂô®‰ø°ÊÅØ
        res.removeHeader('X-Powered-By');
        next();
    });
    
    // ÁîüÁî¢Áí∞Â¢ÉÈåØË™§ËôïÁêÜ
    app.use((err, req, res, next) => {
        // ‰∏çÊö¥Èú≤ÈåØË™§Ë©≥ÊÉÖ
        if (err.status !== 404 && err.status !== 400) {
            console.error('Production error:', err);
        }
        
        res.status(err.status || 500).json({
            success: false,
            error: 'INTERNAL_ERROR',
            message: 'Á≥ªÁµ±Êö´ÊôÇÁÑ°Ê≥ïËôïÁêÜË´ãÊ±Ç'
        });
    });
    
    console.log('‚úÖ ÁîüÁî¢Áí∞Â¢ÉÂ∞àÁî®ÂÆâÂÖ®ÈÖçÁΩÆÂÆåÊàê');
}

/**
 * ‰∏ÄÈçµÈÖçÁΩÆÊâÄÊúâÂÆâÂÖ®‰∏≠Èñì‰ª∂
 */
function configureAllSecurity(app) {
    console.log('üöÄ ÈñãÂßãÈÖçÁΩÆÂÆåÊï¥ÂÆâÂÖ®‰∏≠Èñì‰ª∂Â•ó‰ª∂...');
    
    configureBasicSecurity(app);
    configureAPISecurity(app);
    configureAuthSecurity(app);
    configureFileUploadSecurity(app);
    configureCacheSecurity(app);
    configureProductionSecurity(app);
    
    console.log('üéâ ÂÆåÊï¥ÂÆâÂÖ®‰∏≠Èñì‰ª∂Â•ó‰ª∂ÈÖçÁΩÆÂÆåÊàêÔºÅ');
    console.log('üõ°Ô∏è Á≥ªÁµ±ÂÆâÂÖ®Á≠âÁ¥öÔºöÁîüÁî¢Áí∞Â¢ÉÂ∞±Á∑í');
}

module.exports = {
    configureBasicSecurity,
    configureAPISecurity,
    configureAuthSecurity,
    configureFileUploadSecurity,
    configureCacheSecurity,
    configureProductionSecurity,
    configureAllSecurity
};`;

        fs.writeFileSync(integrationFile, integrationContent);
        
        this.securityResults.securityConfig.push({
            module: 'securityIntegration',
            description: 'ÂÆâÂÖ®‰∏≠Èñì‰ª∂Áµ±‰∏ÄÈõÜÊàê',
            status: 'created'
        });
        
        this.securityResults.createdFiles.push(path.relative(this.projectRoot, integrationFile));
        console.log('  ‚úÖ ÂÆâÂÖ®‰∏≠Èñì‰ª∂ÈõÜÊàêÂâµÂª∫ÂÆåÊàê');
    }

    /**
     * ÁîüÊàêÂÆâÂÖ®Ê™¢Êü•Ê∏ÖÂñÆ
     */
    generateSecurityChecklist() {
        console.log('\nüìã ÁîüÊàêÂÆâÂÖ®Ê™¢Êü•Ê∏ÖÂñÆ...');
        
        const checklistFile = path.join(this.projectRoot, 'SECURITY_CHECKLIST.md');
        
        const checklistContent = `# üõ°Ô∏è ÁîüÁî¢Áí∞Â¢ÉÂÆâÂÖ®Ê™¢Êü•Ê∏ÖÂñÆ

Ê≠§Ê∏ÖÂñÆÁî®ÊñºÁ¢∫‰øùÁ≥ªÁµ±Âú®ÁîüÁî¢Áí∞Â¢ÉÈÉ®ÁΩ≤ÂâçÁ¨¶ÂêàÂÆâÂÖ®Ê®ôÊ∫ñ„ÄÇ

## ‚úÖ Â∑≤ÂÆåÊàêÁöÑÂÆâÂÖ®Êé™ÊñΩ

### üîê Ë™çË≠âËàáÊéàÊ¨ä
- [x] JWT Token ÂÆâÂÖ®ÂØ¶ÊñΩ
- [x] ÂØÜÁ¢ºÂº∑Â∫¶È©óË≠â
- [x] ÁôªÂÖ•ÂòóË©¶ÈôêÂà∂
- [x] Token Êí§Èä∑Ê©üÂà∂
- [x] ÊúÉË©±ÁÆ°ÁêÜÂÆâÂÖ®

### üßπ Ëº∏ÂÖ•È©óË≠âËàáÊ∏ÖÁêÜ
- [x] SQL Ê≥®ÂÖ•Èò≤Ë≠∑
- [x] XSS ÊîªÊìäÈò≤Ë≠∑
- [x] ÂëΩ‰ª§Ê≥®ÂÖ•Èò≤Ë≠∑
- [x] Ë∑ØÂæëÈÅçÊ≠∑Èò≤Ë≠∑
- [x] NoSQL Ê≥®ÂÖ•Èò≤Ë≠∑
- [x] Ê™îÊ°à‰∏äÂÇ≥ÂÆâÂÖ®Ê™¢Êü•

### üåê HTTP ÂÆâÂÖ®Ê®ôÈ†≠
- [x] Content Security Policy (CSP)
- [x] X-Frame-Options
- [x] X-Content-Type-Options
- [x] X-XSS-Protection
- [x] Strict-Transport-Security (HSTS)
- [x] Referrer-Policy
- [x] Permissions-Policy

### üö¶ ÈÄüÁéáÈôêÂà∂
- [x] API Ë´ãÊ±ÇÈôêÂà∂
- [x] ÁôªÂÖ•ÂòóË©¶ÈôêÂà∂
- [x] Ê™îÊ°à‰∏äÂÇ≥ÈôêÂà∂
- [x] ÂàÜÂ±§ÈÄüÁéáÊéßÂà∂

### üìÅ Ê™îÊ°àÂÆâÂÖ®
- [x] Ê™îÊ°àÈ°ûÂûãÈ©óË≠â
- [x] Ê™îÊ°àÂ§ßÂ∞èÈôêÂà∂
- [x] Ê™îÊ°àÂêçÁ®±ÂÆâÂÖ®Ê™¢Êü•
- [x] ‰∏äÂÇ≥Ë∑ØÂæëÈôêÂà∂

## ‚ö†Ô∏è ÈÉ®ÁΩ≤ÂâçÊ™¢Êü•È†ÖÁõÆ

### üîë Áí∞Â¢ÉÈÖçÁΩÆ
- [ ] Êõ¥ÊîπÊâÄÊúâÈ†êË®≠ÂØÜÁ¢ºÂíåÈáëÈë∞
- [ ] Ë®≠ÂÆöÂº∑Â£ØÁöÑ JWT_SECRET
- [ ] ÈÖçÁΩÆÊ≠£Á¢∫ÁöÑ CORS_ORIGIN
- [ ] Ë®≠ÁΩÆÂÆâÂÖ®ÁöÑË≥áÊñôÂ∫´ÈÄ£Êé•Â≠ó‰∏≤
- [ ] ÂïüÁî®Ë≥áÊñôÂ∫´ SSL ÈÄ£Êé•

### üîí SSL/TLS ÈÖçÁΩÆ
- [ ] ÂÆâË£ùÊúâÊïàÁöÑ SSL Ë≠âÊõ∏
- [ ] ÈÖçÁΩÆ HTTPS ÈáçÂÆöÂêë
- [ ] Ê∏¨Ë©¶ SSL ÈÖçÁΩÆÂº∑Â∫¶
- [ ] Ë®≠ÁΩÆË≠âÊõ∏Ëá™ÂãïÊõ¥Êñ∞

### üóÑÔ∏è Ë≥áÊñôÂ∫´ÂÆâÂÖ®
- [ ] Ë≥áÊñôÂ∫´Áî®Êà∂Ê¨äÈôêÊúÄÂ∞èÂåñ
- [ ] ÂïüÁî®Ë≥áÊñôÂ∫´ÂØ©Ë®àÊó•Ë™å
- [ ] ÂÆöÊúüÂÇô‰ªΩË®≠ÁΩÆ
- [ ] Ë≥áÊñôÂä†ÂØÜÈÖçÁΩÆ

### üìä Áõ£ÊéßËàáÊó•Ë™å
- [ ] Ë®≠ÁΩÆÂÆâÂÖ®‰∫ã‰ª∂Áõ£Êéß
- [ ] ÈÖçÁΩÆÊó•Ë™åËº™ËΩâ
- [ ] Ë®≠ÁΩÆÁï∞Â∏∏Ë≠¶Â†±
- [ ] Áõ£ÊéßÁ≥ªÁµ±Ë≥áÊ∫ê‰ΩøÁî®

### üåç Á∂≤Ë∑ØÂÆâÂÖ®
- [ ] Èò≤ÁÅ´ÁâÜË¶èÂâáÈÖçÁΩÆ
- [ ] ‰∏çÂøÖË¶ÅÁ´ØÂè£ÈóúÈñâ
- [ ] VPN ÊàñÂ∞àÁî®Á∂≤Ë∑ØÈÖçÁΩÆ
- [ ] DDoS Èò≤Ë≠∑Ë®≠ÁΩÆ

### üîß Á≥ªÁµ±Âº∑Âåñ
- [ ] ÁßªÈô§‰∏çÂøÖË¶ÅÁöÑËªüÈ´îÂ•ó‰ª∂
- [ ] Á≥ªÁµ±Êõ¥Êñ∞Âà∞ÊúÄÊñ∞ÁâàÊú¨
- [ ] ÊúçÂãôÂ∏≥Êà∂Ê¨äÈôêÊúÄÂ∞èÂåñ
- [ ] Ë®≠ÁΩÆÁ≥ªÁµ±Áõ£Êéß

## üß™ ÂÆâÂÖ®Ê∏¨Ë©¶

### Êª≤ÈÄèÊ∏¨Ë©¶
- [ ] SQL Ê≥®ÂÖ•Ê∏¨Ë©¶
- [ ] XSS ÊîªÊìäÊ∏¨Ë©¶
- [ ] CSRF ÊîªÊìäÊ∏¨Ë©¶
- [ ] Ë∫´‰ªΩÈ©óË≠âÁπûÈÅéÊ∏¨Ë©¶
- [ ] ÊéàÊ¨äÊºèÊ¥ûÊ∏¨Ë©¶

### Ëá™ÂãïÂåñÂÆâÂÖ®ÊéÉÊèè
- [ ] ‰æùË≥¥Â•ó‰ª∂ÊºèÊ¥ûÊéÉÊèè
- [ ] Á®ãÂºèÁ¢ºÂÆâÂÖ®ÊéÉÊèè
- [ ] ÈÖçÁΩÆÂÆâÂÖ®Ê™¢Êü•
- [ ] SSL ÈÖçÁΩÆÊ∏¨Ë©¶

### Â£ìÂäõÊ∏¨Ë©¶
- [ ] API Á´ØÈªûÂ£ìÂäõÊ∏¨Ë©¶
- [ ] Ë≥áÊñôÂ∫´ÈÄ£Êé•Ê±†Ê∏¨Ë©¶
- [ ] Ê™îÊ°à‰∏äÂÇ≥Â£ìÂäõÊ∏¨Ë©¶
- [ ] Ë®òÊÜ∂È´îÊ¥©ÊºèÊ∏¨Ë©¶

## üìù ÂÆâÂÖ®ÊñáÊ™î

### ÂøÖË¶ÅÊñáÊ™î
- [ ] ÂÆâÂÖ®Á≠ñÁï•Êñá‰ª∂
- [ ] ‰∫ã‰ª∂ÂõûÊáâË®àÂäÉ
- [ ] ÂØÜÈë∞ÁÆ°ÁêÜÁ®ãÂ∫è
- [ ] ÂÇô‰ªΩÊÅ¢Âæ©Á®ãÂ∫è
- [ ] Áî®Êà∂Â≠òÂèñÊéßÂà∂ÊîøÁ≠ñ

### Ë®ìÁ∑¥ËàáÊÑèË≠ò
- [ ] ÈñãÁôºÂúòÈöäÂÆâÂÖ®ÂüπË®ì
- [ ] ÂÆâÂÖ®ÊúÄ‰Ω≥ÂØ¶Ë∏êÊñáÊ™î
- [ ] ‰∫ãÊïÖÂõûÂ†±ÊµÅÁ®ã
- [ ] ÂÆöÊúüÂÆâÂÖ®Ë©ï‰º∞Á®ãÂ∫è

## üîÑ ÊåÅÁ∫åÂÆâÂÖ®Á∂≠Ë≠∑

### ÂÆöÊúü‰ªªÂãô
- [ ] ÊØèÂ≠£ÂÆâÂÖ®ÂØ©Ë®à
- [ ] ÊØèÊúà‰æùË≥¥Â•ó‰ª∂Êõ¥Êñ∞
- [ ] ÊØèÈÄ±ÂÆâÂÖ®Êó•Ë™åÊ™¢Êü•
- [ ] ÊØèÊó•Á≥ªÁµ±Áõ£ÊéßÊ™¢Êü•

### ‰∫ã‰ª∂ÁÆ°ÁêÜ
- [ ] Ë®≠ÁΩÆËá™ÂãïÂåñÁõ£ÊéßË≠¶Â†±
- [ ] Âª∫Á´ã‰∫ã‰ª∂ÂõûÊáâÂúòÈöä
- [ ] Ê∫ñÂÇô‰∫ãÊïÖÈÄöË®äÊ®°Êùø
- [ ] ÂÆöÊúüÊºîÁ∑¥‰∫ã‰ª∂ÂõûÊáâ

## üö® Á∑äÊÄ•ËÅØÁµ°Ë≥áË®ä

- Á≥ªÁµ±ÁÆ°ÁêÜÂì°: [ÂæÖÂ°´ÂÖ•]
- ÂÆâÂÖ®ÂúòÈöä: [ÂæÖÂ°´ÂÖ•]
- Ë≥áÊñôÂ∫´ÁÆ°ÁêÜÂì°: [ÂæÖÂ°´ÂÖ•]
- Á∂≤Ë∑ØÁÆ°ÁêÜÂì°: [ÂæÖÂ°´ÂÖ•]

## üìû Â§ñÈÉ®ÂÆâÂÖ®Ë≥áÊ∫ê

- OWASP Top 10: https://owasp.org/www-project-top-ten/
- CVE Ë≥áÊñôÂ∫´: https://cve.mitre.org/
- ÂÆâÂÖ®Âª∫Ë≠∞: https://www.cisa.gov/
- SSL Ê∏¨Ë©¶: https://www.ssllabs.com/ssltest/

---

**Ê™¢Êü•Ê∏ÖÂñÆÁâàÊú¨**: 1.0  
**ÊúÄÂæåÊõ¥Êñ∞**: ${new Date().toLocaleDateString('zh-TW')}  
**‰∏ãÊ¨°Ê™¢Êü•**: ${new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString('zh-TW')}

> ‚ö†Ô∏è **ÈáçË¶ÅÊèêÈÜí**: Ê≠§Ê™¢Êü•Ê∏ÖÂñÆÊáâÂÆöÊúüÊõ¥Êñ∞Ôºå‰∏¶Ê†πÊìöÊúÄÊñ∞ÁöÑÂÆâÂÖ®Â®ÅËÑÖÂíåÊ≥ïË¶èË¶ÅÊ±ÇÈÄ≤Ë°åË™øÊï¥„ÄÇ
`;

        fs.writeFileSync(checklistFile, checklistContent);
        
        this.securityResults.createdFiles.push('SECURITY_CHECKLIST.md');
        console.log('  ‚úÖ ÂÆâÂÖ®Ê™¢Êü•Ê∏ÖÂñÆÁîüÊàêÂÆåÊàê');
    }

    /**
     * ÁîüÊàêÂÆâÂÖ®ÈÖçÁΩÆÂ†±Âëä
     */
    generateSecurityReport() {
        console.log('\nüìä ÁîüÁî¢Áí∞Â¢ÉÂÆâÂÖ®ÈÖçÁΩÆÂ†±Âëä:');
        console.log('='.repeat(70));
        
        // Áí∞Â¢ÉÈÖçÁΩÆÁµ±Ë®à
        console.log('\nüîê Áí∞Â¢ÉÈÖçÁΩÆ:');
        console.log(`  ÂÆâÂÖ®ÈÖçÁΩÆÈ†Ö: ${this.securityResults.environmentVars.length}`);
        this.securityResults.environmentVars.forEach(config => {
            console.log(`    ‚úÖ ${config.description} (${config.status})`);
        });
        
        // HTTP ÂÆâÂÖ®Ê®ôÈ†≠Áµ±Ë®à
        console.log('\nüõ°Ô∏è HTTPÂÆâÂÖ®Ê®ôÈ†≠:');
        console.log(`  ÂÆâÂÖ®Ê®ôÈ†≠Ê®°ÁµÑ: ${this.securityResults.headerSecurity.length}`);
        this.securityResults.headerSecurity.forEach(header => {
            console.log(`    ‚úÖ ${header.description} (${header.status})`);
        });
        
        // Ëº∏ÂÖ•È©óË≠âÁµ±Ë®à
        console.log('\nüßπ Ëº∏ÂÖ•È©óË≠â:');
        console.log(`  È©óË≠âÊ®°ÁµÑ: ${this.securityResults.inputValidation.length}`);
        this.securityResults.inputValidation.forEach(validation => {
            console.log(`    ‚úÖ ${validation.description} (${validation.status})`);
        });
        
        // Ë™çË≠âÂÆâÂÖ®Áµ±Ë®à
        console.log('\nüîê Ë™çË≠âÂÆâÂÖ®:');
        console.log(`  Ë™çË≠âÊ®°ÁµÑ: ${this.securityResults.authenticationSecurity.length}`);
        this.securityResults.authenticationSecurity.forEach(auth => {
            console.log(`    ‚úÖ ${auth.description} (${auth.status})`);
        });
        
        // HTTPS ÈÖçÁΩÆÁµ±Ë®à
        console.log('\nüîí HTTPSÈÖçÁΩÆ:');
        console.log(`  SSLÈÖçÁΩÆÊ®°ÁµÑ: ${this.securityResults.httpsSetup.length}`);
        this.securityResults.httpsSetup.forEach(https => {
            console.log(`    ‚úÖ ${https.description} (${https.status})`);
        });
        
        // Á≥ªÁµ±ÈÖçÁΩÆÁµ±Ë®à
        console.log('\nüîß Á≥ªÁµ±ÈÖçÁΩÆ:');
        console.log(`  ÂÆâÂÖ®ÈõÜÊàêÊ®°ÁµÑ: ${this.securityResults.securityConfig.length}`);
        this.securityResults.securityConfig.forEach(config => {
            console.log(`    ‚úÖ ${config.description} (${config.status})`);
        });
        
        // ÂâµÂª∫Êñá‰ª∂Áµ±Ë®à
        console.log('\nüìÑ Êñ∞Âª∫ÂÆâÂÖ®Êñá‰ª∂:');
        console.log(`  Êñ∞Âª∫Êñá‰ª∂Á∏ΩÊï∏: ${this.securityResults.createdFiles.length}`);
        this.securityResults.createdFiles.forEach(file => {
            console.log(`    üìÑ ${file}`);
        });
        
        // ÂÆâÂÖ®ÊîπÂñÑÂª∫Ë≠∞
        this.generateSecurityRecommendations();
        
        console.log('\n‚úÖ ÁîüÁî¢Áí∞Â¢ÉÂÆâÂÖ®ÈÖçÁΩÆÂÆåÊàê');
        console.log('üõ°Ô∏è Á≥ªÁµ±ÂÆâÂÖ®Á≠âÁ¥ö: ÁîüÁî¢Áí∞Â¢ÉÂ∞±Á∑í');
    }

    /**
     * ÁîüÊàêÂÆâÂÖ®Âª∫Ë≠∞
     */
    generateSecurityRecommendations() {
        console.log('\nüí° ÂÆâÂÖ®ÈÖçÁΩÆÂª∫Ë≠∞:');
        
        const recommendations = [
            'üîë [Á´ãÂç≥Âü∑Ë°å] Êõ¥Êñ∞ .env.production Êñá‰ª∂‰∏≠ÁöÑÊâÄÊúâÂØÜÈë∞',
            'üîí [Á´ãÂç≥Âü∑Ë°å] ÈÖçÁΩÆÁîüÁî¢Áí∞Â¢ÉÁöÑ SSL Ë≠âÊõ∏',
            'üåê [È´òÂÑ™ÂÖàÁ¥ö] Ë®≠ÁΩÆÊ≠£Á¢∫ÁöÑ CORS_ORIGIN ÂüüÂêç',
            'üìä [È´òÂÑ™ÂÖàÁ¥ö] ÈÖçÁΩÆÁîüÁî¢Áí∞Â¢ÉÁõ£ÊéßÂíåÊó•Ë™åÁ≥ªÁµ±',
            'üîß [‰∏≠ÂÑ™ÂÖàÁ¥ö] Âú®‰∏ªÊúçÂãôÂô®Êñá‰ª∂‰∏≠Êï¥ÂêàÂÆâÂÖ®‰∏≠Èñì‰ª∂',
            'üß™ [‰∏≠ÂÑ™ÂÖàÁ¥ö] Âü∑Ë°åÂÆåÊï¥ÁöÑÂÆâÂÖ®Ê∏¨Ë©¶Â•ó‰ª∂',
            'üìã [‰∏≠ÂÑ™ÂÖàÁ¥ö] ÂÆåÊàêÂÆâÂÖ®Ê™¢Êü•Ê∏ÖÂñÆ‰∏≠ÁöÑÊâÄÊúâÈ†ÖÁõÆ',
            'üîÑ [‰ΩéÂÑ™ÂÖàÁ¥ö] Âª∫Á´ãÂÆöÊúüÂÆâÂÖ®ÂØ©Ë®àÊµÅÁ®ã'
        ];

        recommendations.forEach((rec, index) => {
            console.log(`  ${index + 1}. ${rec}`);
        });
        
        this.securityResults.recommendations = recommendations;
    }

    /**
     * Â∞éÂá∫ÂÆâÂÖ®ÈÖçÁΩÆÁµêÊûú
     */
    exportSecurityResults() {
        const reportFile = path.join(this.projectRoot, 'production-security-setup-report.json');
        
        try {
            fs.writeFileSync(reportFile, JSON.stringify(this.securityResults, null, 2));
            console.log(`\nüìÑ ÁîüÁî¢Áí∞Â¢ÉÂÆâÂÖ®ÈÖçÁΩÆÂ†±ÂëäÂ∑≤Â∞éÂá∫: production-security-setup-report.json`);
            return reportFile;
        } catch (error) {
            console.error('‚ùå Â∞éÂá∫ÂÆâÂÖ®ÈÖçÁΩÆÂ†±ÂëäÂ§±Êïó:', error.message);
            return null;
        }
    }
}

// Âü∑Ë°åÁîüÁî¢Áí∞Â¢ÉÂÆâÂÖ®Ë®≠ÁΩÆ
async function main() {
    const security = new ProductionSecuritySetup();
    await security.executeProductionSecuritySetup();
    security.generateSecurityReport();
    security.exportSecurityResults();
}

if (require.main === module) {
    main();
}

module.exports = ProductionSecuritySetup;
#!/usr/bin/env node
/**
 * ğŸ›¡ï¸ å®‰å…¨æ€§æ¼æ´æƒæå’Œä¿®å¾©å»ºè­°
 */

const fs = require('fs');
const path = require('path');

class SecurityVulnerabilityScanner {
    constructor() {
        this.projectRoot = __dirname;
        this.vulnerabilities = [];
        this.securityIssues = {
            critical: [],
            high: [],
            medium: [],
            low: []
        };
    }

    async scanFile(filePath) {
        try {
            const content = fs.readFileSync(filePath, 'utf8');
            const fileName = path.basename(filePath);
            const ext = path.extname(filePath);
            
            console.log(`\nğŸ” æƒææ–‡ä»¶: ${fileName}`);
            
            let issues = [];
            
            // JavaScript/Node.js å®‰å…¨æª¢æŸ¥
            if (ext === '.js') {
                issues = [
                    ...this.checkJavaScriptSecurity(content, fileName),
                    ...this.checkNodeJSSecurity(content, fileName),
                    ...this.checkSQLInjection(content, fileName),
                    ...this.checkXSS(content, fileName)
                ];
            }
            
            // HTML å®‰å…¨æª¢æŸ¥
            if (ext === '.html') {
                issues = [
                    ...this.checkHTMLSecurity(content, fileName),
                    ...this.checkCSRF(content, fileName),
                    ...this.checkXSS(content, fileName)
                ];
            }
            
            // JSON é…ç½®æª¢æŸ¥
            if (ext === '.json' && (fileName === 'package.json' || fileName.includes('config'))) {
                issues = this.checkConfigSecurity(content, fileName);
            }
            
            // åˆ†é¡å®‰å…¨å•é¡Œ
            issues.forEach(issue => {
                this.securityIssues[issue.severity].push(issue);
            });
            
            if (issues.length > 0) {
                console.log(`  ç™¼ç¾ ${issues.length} å€‹å®‰å…¨å•é¡Œ`);
                issues.forEach(issue => {
                    const icon = this.getSeverityIcon(issue.severity);
                    console.log(`    ${icon} ${issue.type}: ${issue.description}`);
                });
            } else {
                console.log('  âœ… æœªç™¼ç¾æ˜é¡¯å®‰å…¨å•é¡Œ');
            }
            
            return issues;
            
        } catch (error) {
            console.error(`âŒ æƒææ–‡ä»¶å¤±æ•—: ${filePath}`, error.message);
            return [];
        }
    }

    checkJavaScriptSecurity(content, fileName) {
        const issues = [];
        
        // æª¢æŸ¥ eval() ä½¿ç”¨
        if (/eval\s*\(/g.test(content)) {
            issues.push({
                file: fileName,
                type: 'Code Injection',
                severity: 'critical',
                description: 'ä½¿ç”¨ eval() å¯èƒ½å°è‡´ä»£ç¢¼æ³¨å…¥æ”»æ“Š',
                line: this.getLineNumber(content, /eval\s*\(/),
                fix: 'é¿å…ä½¿ç”¨ eval()ï¼Œä½¿ç”¨ JSON.parse() æˆ–å…¶ä»–å®‰å…¨æ›¿ä»£æ–¹æ¡ˆ'
            });
        }
        
        // æª¢æŸ¥ setTimeout/setInterval å­—ä¸²åŸ·è¡Œ
        if (/setTimeout\s*\(\s*['"]/g.test(content) || /setInterval\s*\(\s*['"]/g.test(content)) {
            issues.push({
                file: fileName,
                type: 'Code Injection',
                severity: 'high',
                description: 'setTimeout/setInterval ä½¿ç”¨å­—ä¸²å¯èƒ½å°è‡´ä»£ç¢¼æ³¨å…¥',
                fix: 'ä½¿ç”¨å‡½æ•¸è€Œéå­—ä¸²ä½œç‚ºåƒæ•¸'
            });
        }
        
        // æª¢æŸ¥ç¡¬ç·¨ç¢¼æ•æ„Ÿè³‡è¨Š
        const sensitivePatterns = [
            { pattern: /(password|pwd|passwd)\s*[:=]\s*['"]\w+['"]/, type: 'ç¡¬ç·¨ç¢¼å¯†ç¢¼' },
            { pattern: /(api[_-]?key|apikey)\s*[:=]\s*['"]\w+['"]/, type: 'ç¡¬ç·¨ç¢¼APIå¯†é‘°' },
            { pattern: /(secret|token)\s*[:=]\s*['"]\w+['"]/, type: 'ç¡¬ç·¨ç¢¼ç§˜å¯†' }
        ];
        
        sensitivePatterns.forEach(({ pattern, type }) => {
            if (pattern.test(content)) {
                issues.push({
                    file: fileName,
                    type: 'Sensitive Data Exposure',
                    severity: 'high',
                    description: `ç™¼ç¾${type}`,
                    fix: 'ä½¿ç”¨ç’°å¢ƒè®Šæ•¸æˆ–é…ç½®æ–‡ä»¶å­˜å„²æ•æ„Ÿè³‡è¨Š'
                });
            }
        });
        
        return issues;
    }

    checkNodeJSSecurity(content, fileName) {
        const issues = [];
        
        // æª¢æŸ¥ä¸å®‰å…¨çš„ require
        if (/require\s*\(\s*[^'"]*user[^'"]*\)/g.test(content)) {
            issues.push({
                file: fileName,
                type: 'Path Traversal',
                severity: 'medium',
                description: 'require() ä½¿ç”¨ç”¨æˆ¶è¼¸å…¥å¯èƒ½å°è‡´è·¯å¾‘éæ­·æ”»æ“Š',
                fix: 'é©—è­‰å’Œæ¸…ç†ç”¨æˆ¶è¼¸å…¥ï¼Œä½¿ç”¨ç™½åå–®'
            });
        }
        
        // æª¢æŸ¥ Buffer ä¸å®‰å…¨ä½¿ç”¨
        if (/new Buffer\(/g.test(content)) {
            issues.push({
                file: fileName,
                type: 'Memory Disclosure',
                severity: 'medium',
                description: 'ä½¿ç”¨éæ™‚çš„ Buffer() æ§‹é€ å‡½æ•¸',
                fix: 'ä½¿ç”¨ Buffer.from(), Buffer.alloc() æˆ– Buffer.allocUnsafe()'
            });
        }
        
        // æª¢æŸ¥ä¸å®‰å…¨çš„åŠ å¯†
        if (/crypto\.createHash\(['"]md5['"]\)/g.test(content)) {
            issues.push({
                file: fileName,
                type: 'Weak Cryptography',
                severity: 'medium',
                description: 'MD5 æ˜¯ä¸å®‰å…¨çš„é›œæ¹Šç®—æ³•',
                fix: 'ä½¿ç”¨ SHA-256 æˆ–æ›´å¼·çš„é›œæ¹Šç®—æ³•'
            });
        }
        
        return issues;
    }

    checkSQLInjection(content, fileName) {
        const issues = [];
        
        // æª¢æŸ¥ SQL æ³¨å…¥é¢¨éšª
        const sqlPatterns = [
            /`[^`]*\$\{[^}]*\}[^`]*`/g, // æ¨¡æ¿å­—ä¸²ä¸­çš„ SQL
            /['"][^'"]*\+[^'"]*['"]/g,  // å­—ä¸²æ‹¼æ¥ SQL
            /query\s*\(\s*[^,)]*\+[^,)]*\)/g // query æ–¹æ³•ä¸­çš„å­—ä¸²æ‹¼æ¥
        ];
        
        sqlPatterns.forEach(pattern => {
            if (pattern.test(content)) {
                issues.push({
                    file: fileName,
                    type: 'SQL Injection',
                    severity: 'critical',
                    description: 'å¯èƒ½å­˜åœ¨ SQL æ³¨å…¥é¢¨éšª',
                    fix: 'ä½¿ç”¨åƒæ•¸åŒ–æŸ¥è©¢æˆ– ORM ä¾†é¿å… SQL æ³¨å…¥'
                });
            }
        });
        
        return issues;
    }

    checkXSS(content, fileName) {
        const issues = [];
        
        // æª¢æŸ¥ XSS é¢¨éšª
        const xssPatterns = [
            /innerHTML\s*=.*\+/g,
            /document\.write\s*\(/g,
            /\.html\s*\(.*\+.*\)/g
        ];
        
        xssPatterns.forEach(pattern => {
            if (pattern.test(content)) {
                issues.push({
                    file: fileName,
                    type: 'Cross-Site Scripting (XSS)',
                    severity: 'high',
                    description: 'å¯èƒ½å­˜åœ¨ XSS æ”»æ“Šé¢¨éšª',
                    fix: 'å°ç”¨æˆ¶è¼¸å…¥é€²è¡Œé©ç•¶çš„ç·¨ç¢¼å’Œé©—è­‰'
                });
            }
        });
        
        return issues;
    }

    checkHTMLSecurity(content, fileName) {
        const issues = [];
        
        // æª¢æŸ¥ç¼ºå°‘çš„å®‰å…¨æ¨™é ­
        if (!/<meta.*http-equiv=['"]X-UA-Compatible['"].*>/i.test(content)) {
            issues.push({
                file: fileName,
                type: 'Security Headers',
                severity: 'low',
                description: 'ç¼ºå°‘ X-UA-Compatible æ¨™é ­',
                fix: 'æ·»åŠ é©ç•¶çš„å®‰å…¨æ¨™é ­'
            });
        }
        
        // æª¢æŸ¥å…§åµŒè…³æœ¬
        if (/<script[^>]*>(?!.*src=).*<\/script>/gs.test(content)) {
            issues.push({
                file: fileName,
                type: 'Content Security Policy',
                severity: 'medium',
                description: 'ä½¿ç”¨å…§åµŒè…³æœ¬å¯èƒ½é•å CSP',
                fix: 'å°‡è…³æœ¬ç§»åˆ°å¤–éƒ¨æ–‡ä»¶ä¸¦å¯¦æ–½ CSP'
            });
        }
        
        // æª¢æŸ¥ä¸å®‰å…¨çš„é€£çµ
        if (/<a[^>]*target=['"]_blank['"][^>]*>/g.test(content) && 
            !/<a[^>]*rel=['"][^'"]*noopener[^'"]*['"][^>]*>/g.test(content)) {
            issues.push({
                file: fileName,
                type: 'Security Misconfiguration',
                severity: 'medium',
                description: 'target="_blank" æ²’æœ‰ rel="noopener" å¯èƒ½å°è‡´å®‰å…¨å•é¡Œ',
                fix: 'ç‚º target="_blank" é€£çµæ·»åŠ  rel="noopener noreferrer"'
            });
        }
        
        return issues;
    }

    checkCSRF(content, fileName) {
        const issues = [];
        
        // æª¢æŸ¥è¡¨å–®æ˜¯å¦æœ‰ CSRF ä¿è­·
        if (/<form[^>]*>/g.test(content)) {
            if (!/csrf|_token/gi.test(content)) {
                issues.push({
                    file: fileName,
                    type: 'Cross-Site Request Forgery (CSRF)',
                    severity: 'high',
                    description: 'è¡¨å–®å¯èƒ½ç¼ºå°‘ CSRF ä¿è­·',
                    fix: 'ç‚ºè¡¨å–®æ·»åŠ  CSRF token'
                });
            }
        }
        
        return issues;
    }

    checkConfigSecurity(content, fileName) {
        const issues = [];
        
        try {
            const config = JSON.parse(content);
            
            // æª¢æŸ¥éæ™‚çš„ä¾è³´
            if (config.dependencies) {
                Object.entries(config.dependencies).forEach(([pkg, version]) => {
                    if (this.isOutdatedPackage(pkg, version)) {
                        issues.push({
                            file: fileName,
                            type: 'Vulnerable Dependencies',
                            severity: 'medium',
                            description: `ä¾è³´ ${pkg}@${version} å¯èƒ½æœ‰å®‰å…¨æ¼æ´`,
                            fix: 'æ›´æ–°åˆ°æœ€æ–°çš„å®‰å…¨ç‰ˆæœ¬'
                        });
                    }
                });
            }
            
        } catch (error) {
            console.log(`  âš ï¸ ç„¡æ³•è§£æ JSON æ–‡ä»¶: ${fileName}`);
        }
        
        return issues;
    }

    isOutdatedPackage(packageName, version) {
        // ç°¡åŒ–çš„éæ™‚åŒ…æª¢æŸ¥é‚è¼¯
        const knownVulnerablePackages = ['lodash', 'moment', 'axios'];
        return knownVulnerablePackages.includes(packageName);
    }

    getSeverityIcon(severity) {
        const icons = {
            critical: 'ğŸš¨',
            high: 'âš ï¸',
            medium: 'âš¡',
            low: 'â„¹ï¸'
        };
        return icons[severity] || 'â„¹ï¸';
    }

    getLineNumber(content, pattern) {
        const match = content.match(pattern);
        if (match) {
            const beforeMatch = content.substring(0, match.index);
            return beforeMatch.split('\n').length;
        }
        return null;
    }

    async runSecurityScan() {
        console.log('ğŸš€ é–‹å§‹å®‰å…¨æ€§æ¼æ´æƒæ...');
        console.log('='.repeat(60));
        
        try {
            // æƒæçš„æ–‡ä»¶é¡å‹å’Œç›®éŒ„
            const scanPaths = [
                { dir: 'server', extensions: ['.js'] },
                { dir: 'public', extensions: ['.html', '.js'] },
                { dir: '.', files: ['package.json'] }
            ];
            
            for (const scanPath of scanPaths) {
                if (scanPath.files) {
                    // æƒæç‰¹å®šæ–‡ä»¶
                    for (const file of scanPath.files) {
                        const filePath = path.join(this.projectRoot, file);
                        if (fs.existsSync(filePath)) {
                            await this.scanFile(filePath);
                        }
                    }
                } else {
                    // æƒæç›®éŒ„ä¸­çš„æ–‡ä»¶
                    const dirPath = path.join(this.projectRoot, scanPath.dir);
                    if (fs.existsSync(dirPath)) {
                        const files = this.getFilesRecursively(dirPath, scanPath.extensions);
                        for (const file of files) {
                            await this.scanFile(file);
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                    }
                }
            }
            
            this.generateSecurityReport();
            
        } catch (error) {
            console.error('âŒ å®‰å…¨æƒæåŸ·è¡Œå¤±æ•—:', error);
        }
    }

    getFilesRecursively(dir, extensions) {
        const files = [];
        
        try {
            const entries = fs.readdirSync(dir, { withFileTypes: true });
            
            for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                
                if (entry.isDirectory() && entry.name !== 'node_modules') {
                    files.push(...this.getFilesRecursively(fullPath, extensions));
                } else if (entry.isFile() && extensions.includes(path.extname(entry.name))) {
                    files.push(fullPath);
                }
            }
        } catch (error) {
            console.error(`âŒ è®€å–ç›®éŒ„å¤±æ•—: ${dir}`);
        }
        
        return files;
    }

    generateSecurityReport() {
        console.log('\nğŸ›¡ï¸ å®‰å…¨æ€§æƒæç¶œåˆå ±å‘Š:');
        console.log('='.repeat(60));
        
        const severityLevels = ['critical', 'high', 'medium', 'low'];
        let totalIssues = 0;
        
        severityLevels.forEach(level => {
            const issues = this.securityIssues[level];
            totalIssues += issues.length;
            
            if (issues.length > 0) {
                console.log(`\n${this.getSeverityIcon(level)} ${level.toUpperCase()} ç´šåˆ¥å•é¡Œ (${issues.length} é …):`);
                
                issues.forEach((issue, index) => {
                    console.log(`  ${index + 1}. ${issue.type} - ${issue.file}`);
                    console.log(`     ${issue.description}`);
                    if (issue.fix) {
                        console.log(`     ğŸ’¡ ä¿®å¾©å»ºè­°: ${issue.fix}`);
                    }
                    console.log('');
                });
            }
        });
        
        // é¢¨éšªè©•ç´š
        let riskLevel = 'LOW';
        if (this.securityIssues.critical.length > 0) riskLevel = 'CRITICAL';
        else if (this.securityIssues.high.length > 0) riskLevel = 'HIGH';
        else if (this.securityIssues.medium.length > 0) riskLevel = 'MEDIUM';
        
        console.log('\nğŸ“ˆ å®‰å…¨æ€§é¢¨éšªè©•ä¼°:');
        console.log(`  ç¸½ç™¼ç¾å•é¡Œæ•¸: ${totalIssues}`);
        console.log(`  ğŸš¨ åš´é‡: ${this.securityIssues.critical.length}`);
        console.log(`  âš ï¸ é«˜é¢¨éšª: ${this.securityIssues.high.length}`);
        console.log(`  âš¡ ä¸­é¢¨éšª: ${this.securityIssues.medium.length}`);
        console.log(`  â„¹ï¸ ä½é¢¨éšª: ${this.securityIssues.low.length}`);
        console.log(`  ğŸ¯ æ•´é«”é¢¨éšªç´šåˆ¥: ${riskLevel}`);
        
        // å®‰å…¨å»ºè­°
        console.log('\nğŸ”’ å®‰å…¨åŠ å›ºå»ºè­°:');
        console.log('  1. å®šæœŸæ›´æ–°ä¾è³´åŒ…åˆ°æœ€æ–°ç‰ˆæœ¬');
        console.log('  2. å¯¦æ–½å…§å®¹å®‰å…¨æ”¿ç­– (CSP)');
        console.log('  3. ä½¿ç”¨ HTTPS å’Œå®‰å…¨æ¨™é ­');
        console.log('  4. å°æ‰€æœ‰ç”¨æˆ¶è¼¸å…¥é€²è¡Œé©—è­‰å’Œæ¸…ç†');
        console.log('  5. å¯¦æ–½é©ç•¶çš„èº«ä»½é©—è­‰å’Œæˆæ¬Š');
        console.log('  6. å®šæœŸé€²è¡Œå®‰å…¨å¯©è¨ˆå’Œæ»²é€æ¸¬è©¦');
        
        console.log('\nâœ… å®‰å…¨æ€§æ¼æ´æƒæå®Œæˆ');
    }
}

async function main() {
    const scanner = new SecurityVulnerabilityScanner();
    await scanner.runSecurityScan();
}

main();
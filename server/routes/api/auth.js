/**
 * Ë™çË≠âÁõ∏ÈóúË∑ØÁî±
 */

const express = require('express');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { initModels } = require('../../models');
const logger = require('../../utils/logger');
const responseHelper = require('../../utils/responseHelper');
const notificationService = require('../../services/notificationService');

const router = express.Router();
let models = null;

// ÂàùÂßãÂåñÊ®°Âûã
const initializeModels = async () => {
    if (!models) {
        models = await initModels();
    }
    return models;
};

/**
 * Áî®Êà∂ÁôªÂÖ• (ÊîØÊè¥Â§öÁ®ÆÁôªÂÖ•ÊñπÂºè)
 */
router.post('/login', async (req, res) => {
    try {
        await initializeModels();
        const { employeeId, password, name, idNumber } = req.body;

        let whereClause = {};
        let authMethod = '';

        // ÊîØÊè¥ employeeId + password ÁôªÂÖ•ÊñπÂºè
        if (employeeId && password) {
            whereClause = { employeeId };
            authMethod = 'employeeId';
        }
        // ÊîØÊè¥ name + idNumber ÁôªÂÖ•ÊñπÂºè (ËàäÁâàÊú¨)
        else if (name && idNumber) {
            whereClause = { name, idNumber };
            authMethod = 'nameId';
        }
        else {
            return responseHelper.error(res, 'Ë´ãÊèê‰æõÊúâÊïàÁöÑÁôªÂÖ•ÊÜëË≠â', 'INVALID_CREDENTIALS', 400);
        }

        // Êü•ÊâæÂì°Â∑•
        const employee = await models.Employee.findOne({
            where: whereClause,
            include: [{
                model: models.Store,
                attributes: ['name', 'address']
            }]
        });

        if (!employee) {
            return responseHelper.error(res, 'Âì°Â∑•Ë≥áÊñô‰∏çÂ≠òÂú®ÊàñÁôªÂÖ•ÊÜëË≠âÈåØË™§', 'LOGIN_FAILED', 401);
        }

        if (employee.status !== 'Âú®ËÅ∑') {
            return responseHelper.error(res, 'Âì°Â∑•ÁãÄÊÖãÁï∞Â∏∏ÔºåÁÑ°Ê≥ïÁôªÂÖ•', 'INACTIVE_EMPLOYEE', 403);
        }

        // Â¶ÇÊûú‰ΩøÁî®ÂØÜÁ¢ºÁôªÂÖ•ÔºåÈúÄË¶ÅÈ©óË≠âÂØÜÁ¢º
        if (authMethod === 'employeeId' && password) {
            if (!employee.password) {
                return responseHelper.error(res, 'Ê≠§Âì°Â∑•Â∞öÊú™Ë®≠ÂÆöÂØÜÁ¢º', 'PASSWORD_NOT_SET', 401);
            }

            const isValidPassword = await bcrypt.compare(password, employee.password);
            if (!isValidPassword) {
                return responseHelper.error(res, 'ÂØÜÁ¢ºÈåØË™§', 'INVALID_PASSWORD', 401);
            }
        }

        // ÁîüÊàê JWT
        const token = jwt.sign(
            { 
                id: employee.id,
                employeeId: employee.employeeId,
                name: employee.name,
                position: employee.position,
                storeId: employee.storeId,
                role: employee.position
            },
            process.env.JWT_SECRET || 'default-secret',
            { expiresIn: '7d' }
        );

        // Ë®òÈåÑÁôªÂÖ•Êó•Ë™å
        logger.info(`üë§ Âì°Â∑•ÁôªÂÖ•: ${employee.name} (${employee.position}) - ${authMethod}`);

        responseHelper.success(res, {
            token,
            employee: {
                id: employee.id,
                employeeId: employee.employeeId,
                name: employee.name,
                position: employee.position,
                storeId: employee.storeId,
                store: employee.Store
            }
        }, 'ÁôªÂÖ•ÊàêÂäü');

    } catch (error) {
        logger.error('‚ùå ÁôªÂÖ•Â§±Êïó:', error);
        responseHelper.error(res, 'ÁôªÂÖ•Â§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶', 'LOGIN_ERROR', 500);
    }
});

/**
 * Êñ∞Âì°Â∑•Ë®ªÂÜä
 */
router.post('/register', async (req, res) => {
    try {
        await initializeModels();
        
        const {
            employeeId, name, email, password, role, storeId,
            idNumber, birthday, gender, hasLicense,
            phone, address, emergencyContact, relationship,
            emergencyPhone, startDate
        } = req.body;

        // Ëº∏ÂÖ•È©óË≠â
        const requiredFields = {
            employeeId: 'Âì°Â∑•Á∑®Ëôü',
            name: 'ÂßìÂêç',
            password: 'ÂØÜÁ¢º'
        };
        
        for (const [field, label] of Object.entries(requiredFields)) {
            if (!req.body[field]) {
                return responseHelper.error(res, `Ë´ãËº∏ÂÖ•${label}`, 'MISSING_FIELD', 400);
            }
        }

        // Ê™¢Êü•Âì°Â∑•Á∑®ËôüÊòØÂê¶Â∑≤Â≠òÂú®
        const existingEmployee = await models.Employee.findOne({
            where: { employeeId }
        });

        if (existingEmployee) {
            return responseHelper.error(res, 'Âì°Â∑•Á∑®ËôüÂ∑≤Â≠òÂú®', 'EMPLOYEE_ID_EXISTS', 400);
        }

        // Ê™¢Êü•emailÊòØÂê¶Â∑≤Â≠òÂú®
        if (email) {
            const existingEmail = await models.Employee.findOne({
                where: { email }
            });

            if (existingEmail) {
                return responseHelper.error(res, 'ÈõªÂ≠ê‰ø°ÁÆ±Â∑≤Ë¢´‰ΩøÁî®', 'EMAIL_EXISTS', 400);
            }
        }

        // Âä†ÂØÜÂØÜÁ¢º
        const hashedPassword = await bcrypt.hash(password, 10);

        // Á¢∫‰øùËá≥Â∞ëÊúâ‰∏ÄÂÄãStoreÂ≠òÂú®
        let targetStoreId = storeId || 1;
        const storeCount = await models.Store.count();
        if (storeCount === 0) {
            // ÂâµÂª∫È†êË®≠Store
            const defaultStore = await models.Store.create({
                name: 'È†êË®≠ÂàÜÂ∫ó',
                minPeople: 2,
                openTime: '1500-0200',
                latitude: 24.9748412,
                longitude: 121.2556713,
                radius: 100,
                address: 'È†êË®≠Âú∞ÂùÄ'
            });
            targetStoreId = defaultStore.id;
        }

        // ÂâµÂª∫Âì°Â∑•Ë®òÈåÑ
        const employee = await models.Employee.create({
            employeeId,
            name,
            email: email || null,
            password: hashedPassword,
            position: role || 'Âì°Â∑•',
            storeId: targetStoreId,
            status: 'Âú®ËÅ∑',
            idNumber: idNumber || null,
            birthday: birthday || null,
            gender: gender || null,
            hasLicense: hasLicense || false,
            phone: phone || null,
            address: address || null,
            emergencyContact: emergencyContact || null,
            relationship: relationship || null,
            emergencyPhone: emergencyPhone || null,
            startDate: startDate || new Date()
        });

        logger.info(`üë§ Êñ∞Âì°Â∑•Ë®ªÂÜä: ${employee.name} (${employee.employeeId})`);

        responseHelper.success(res, {
            employee: {
                id: employee.id,
                employeeId: employee.employeeId,
                name: employee.name,
                email: employee.email,
                position: employee.position,
                storeId: employee.storeId,
                status: employee.status
            }
        }, 'Âì°Â∑•Ë®ªÂÜäÊàêÂäü');

    } catch (error) {
        logger.error('‚ùå Âì°Â∑•Ë®ªÂÜäÂ§±Êïó:', error);
        responseHelper.error(res, 'Âì°Â∑•Ë®ªÂÜäÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶', 'REGISTER_ERROR', 500);
    }
});

/**
 * ËàäÁâàË®ªÂÜä (‰øùÊåÅÂêëÂæåÁõ∏ÂÆπ)
 */
router.post('/register-old', async (req, res) => {
    try {
        await initializeModels();
        
        const {
            name, idNumber, birthday, gender, hasLicense,
            phone, address, emergencyContact, relationship,
            emergencyPhone, startDate
        } = req.body;

        // Ëº∏ÂÖ•È©óË≠â
        const requiredFields = {
            name, idNumber, birthday, gender,
            phone, address, emergencyContact, relationship,
            emergencyPhone, startDate
        };

        for (const [field, value] of Object.entries(requiredFields)) {
            if (!value) {
                return responseHelper.error(res, `${field} ÁÇ∫ÂøÖÂ°´Ê¨Ñ‰Ωç`, 400);
            }
        }

        // Ê™¢Êü•ÊòØÂê¶Â∑≤Â≠òÂú®
        const existingEmployee = await models.Employee.findOne({
            where: { idNumber }
        });

        if (existingEmployee) {
            return responseHelper.error(res, 'Ê≠§Ë∫´ÂàÜË≠âËôüÁ¢ºÂ∑≤Ë®ªÂÜä', 400);
        }

        // ÂâµÂª∫Êñ∞Âì°Â∑• (È†êË®≠ÂàÜÈÖçÂà∞ÂÖßÂ£¢Âø†Â≠ùÂ∫ó)
        const employee = await models.Employee.create({
            name,
            idNumber,
            birthday,
            gender,
            hasLicense: hasLicense || false,
            phone,
            address,
            emergencyContact,
            relationship,
            emergencyPhone,
            startDate,
            storeId: 1, // È†êË®≠ÂÖßÂ£¢Âø†Â≠ùÂ∫ó
            position: 'ÂØ¶ÁøíÁîü',
            status: 'ÂØ©Ê†∏‰∏≠'
        });

        // ÁôºÈÄÅÈÄöÁü•
        await notificationService.sendNewEmployeeNotification(employee);

        logger.info(`üÜï Êñ∞Âì°Â∑•Ë®ªÂÜä: ${employee.name}`);

        responseHelper.success(res, {
            id: employee.id,
            message: 'Ë®ªÂÜäÊàêÂäüÔºåÁ≠âÂæÖÁÆ°ÁêÜÂì°ÂØ©Ê†∏'
        }, 'Ë®ªÂÜäÊàêÂäü');

    } catch (error) {
        logger.error('‚ùå Ë®ªÂÜäÂ§±Êïó:', error);
        responseHelper.error(res, 'Ë®ªÂÜäÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶', 500);
    }
});

/**
 * È©óË≠âToken
 */
router.post('/verify', async (req, res) => {
    try {
        const token = req.headers.authorization?.replace('Bearer ', '');
        
        if (!token) {
            return responseHelper.error(res, 'Token‰∏çÂ≠òÂú®', 401);
        }

        const decoded = jwt.verify(token, process.env.JWT_SECRET || 'default-secret');
        
        await initializeModels();
        const employee = await models.Employee.findByPk(decoded.id, {
            include: [{
                model: models.Store,
                attributes: ['name', 'address']
            }]
        });

        if (!employee || employee.status !== 'Âú®ËÅ∑') {
            return responseHelper.error(res, 'TokenÁÑ°Êïà', 401);
        }

        responseHelper.success(res, {
            user: {
                id: employee.id,
                name: employee.name,
                position: employee.position,
                storeId: employee.storeId,
                store: employee.Store
            }
        }, 'TokenÊúâÊïà');

    } catch (error) {
        logger.error('‚ùå TokenÈ©óË≠âÂ§±Êïó:', error);
        responseHelper.error(res, 'TokenÁÑ°Êïà', 401);
    }
});

/**
 * Áç≤ÂèñÂì°Â∑•Ë≥áÊñô
 */
router.get('/profile', async (req, res) => {
    try {
        const token = req.headers.authorization?.replace('Bearer ', '');
        
        if (!token) {
            return responseHelper.error(res, 'Ë´ãÂÖàÁôªÂÖ•', 401);
        }

        const decoded = jwt.verify(token, process.env.JWT_SECRET || 'default-secret');
        
        await initializeModels();
        const employee = await models.Employee.findByPk(decoded.id, {
            include: [{
                model: models.Store,
                attributes: ['name', 'address', 'latitude', 'longitude', 'radius']
            }]
        });

        if (!employee) {
            return responseHelper.error(res, 'Âì°Â∑•‰∏çÂ≠òÂú®', 404);
        }

        responseHelper.success(res, {
            id: employee.id,
            name: employee.name,
            position: employee.position,
            phone: employee.phone,
            storeId: employee.storeId,
            store: employee.Store,
            status: employee.status
        }, 'Áç≤ÂèñÊàêÂäü');

    } catch (error) {
        logger.error('‚ùå Áç≤ÂèñÂì°Â∑•Ë≥áÊñôÂ§±Êïó:', error);
        responseHelper.error(res, 'Áç≤ÂèñÂ§±Êïó', 500);
    }
});

// Ê∏¨Ë©¶Ë∑ØÁî±
router.get('/test', (req, res) => {
    res.json({
        success: true,
        message: 'Ë™çË≠âË∑ØÁî±Ê∏¨Ë©¶ÊàêÂäü',
        timestamp: new Date().toISOString()
    });
});


// Âì°Â∑•Ë®ªÂÜäÁ´ØÈªû
router.post('/register', async (req, res) => {
    try {
        const result = await registerController(req, res);
        res.json({
            success: true,
            data: result,
            message: 'Êìç‰ΩúÊàêÂäü'
        });
    } catch (error) {
        console.error('Âì°Â∑•Ë®ªÂÜäÁ´ØÈªûÈåØË™§:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            message: 'ÊúçÂãôÂô®ÂÖßÈÉ®ÈåØË™§'
        });
    }
});


// Âì°Â∑•ÁôªÂÖ•Á´ØÈªû
router.post('/login', async (req, res) => {
    try {
        const result = await loginController(req, res);
        res.json({
            success: true,
            data: result,
            message: 'Êìç‰ΩúÊàêÂäü'
        });
    } catch (error) {
        console.error('Âì°Â∑•ÁôªÂÖ•Á´ØÈªûÈåØË™§:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            message: 'ÊúçÂãôÂô®ÂÖßÈÉ®ÈåØË™§'
        });
    }
});


// TokenÈ©óË≠âÁ´ØÈªû
router.get('/verify', async (req, res) => {
    try {
        const result = await verifyController(req, res);
        res.json({
            success: true,
            data: result,
            message: 'Êìç‰ΩúÊàêÂäü'
        });
    } catch (error) {
        console.error('TokenÈ©óË≠âÁ´ØÈªûÈåØË™§:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            message: 'ÊúçÂãôÂô®ÂÖßÈÉ®ÈåØË™§'
        });
    }
});

module.exports = router;